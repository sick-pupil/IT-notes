## 1. 判断对象存活标准
- ### 引用计数算法
	在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的
	缺陷：两个对象中互相存在对方的引用，则无法引用引用计数算法回收对象

- ### 可达性分析算法
	通过一系列称为“`GC Roots`”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（`Reference Chain`），如果某个对象到`GC Roots`间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用<img src="D:\Project\IT notes\Java\JVM\img\利用可达性分析算法判定对象是否可以回收.png" style="width:500px;height:400px;" />
	
	在Java技术体系里面，固定可作为GC Roots的对象包括以下几种：
	1. 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等
	2. 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量
	3. 在方法区中常量引用的对象，譬如字符串常量池（`String Table`）里的引用
	4. 在本地方法栈中JNI（即通常所说的Native方法）引用的对象
	5. Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如`NullPointExcepiton OutOfMemoryError`）等，还有系统类加载器
	6. 所有被同步锁（`synchronized`关键字）持有的对象
	7. 反映Java虚拟机内部情况的`JMXBean`、`JVMTI`中注册的回调、本地代码缓存等
	8. 针对分代垃圾收集，譬如发起新生代垃圾收集，新生代区域中存在部分对象被老年代区域对象所引用，则将这部分存在跨域引用关系的老年代对象一并加入`GC Roots`中

## 2. 引用类型
- **强引用**：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“`Object obj=new Object()`”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象
- **软引用SoftReference**：用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常
- **弱引用WeakReference**：用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象
- **虚引用PhantomReference**：为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知

## 3. 判断对象死亡过程
即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的

要真正宣告一个对象死亡，至少要经历两次标记过程：
1. 如果对象在进行可达性分析后发现没有与`GC Roots`相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行`finalize()`方法
	假如对象没有覆盖`finalize()`方法，或者`finalize()`方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”
2. 如果这个对象被判定为确有必要执行`finalize()`方法，那么该对象将会被放置在一个名为`F-Queue`的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的`Finalizer`线程去执行它们的`finalize()`方法。稍后收集器将对`F-Queue`中的对象进行第二次小规模的标记

#### 示例代码
```java
/**
 * 此代码演示了两点：
 * 1.对象可以在被GC时自我拯救。
 * 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次
 * @author zzm
 */
public class FinalizeEscapeGC
{
    public static FinalizeEscapeGC SAVE_HOOK = null;
    public void isAlive()
    {
        System.out.println("yes, i am still alive :)");
    }
    @Override
    protected void finalize() throws Throwable
    {
        super.finalize();
        System.out.println("finalize method executed!");
        FinalizeEscapeGC.SAVE_HOOK = this;
    }
    public static void main(String[] args) throws Throwable
    {
        SAVE_HOOK = new FinalizeEscapeGC();
        //对象第一次成功拯救自己
        SAVE_HOOK = null;
        System.gc();
        // 因为Finalizer方法优先级很低，暂停0.5秒，以等待它
        Thread.sleep(500);
        if(SAVE_HOOK != null)
        {
            SAVE_HOOK.isAlive();
        }
        else
        {
            System.out.println("no, i am dead :(");
        }
        // 下面这段代码与上面的完全相同，但是这次自救却失败了
        SAVE_HOOK = null;
        System.gc();
        // 因为Finalizer方法优先级很低，暂停0.5秒，以等待它
        Thread.sleep(500);
        if(SAVE_HOOK != null)
        {
            SAVE_HOOK.isAlive();
        }
        else
        {
            System.out.println("no, i am dead :(");
        }
    }
}
```

## 4. 方法区回收
方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型。回收废弃常量与回收Java堆中的对象非常类似
例子：假如一个字符串“java”曾经进入常量池中，但是当前系统又没有任何一个字符串对象的值是“java”，换句话说，已经没有任何字符串对象引用常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且垃圾收集器判断确有必要的话，这个“java”常量就将会被系统清理出常量池

而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：
1. 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例
2. 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如`OSGi`、`JSP`的重加载等，否则通常是很难达成的
3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

## 5. 垃圾回收算法
**分代收集理论**：
1. 弱分代假说：绝大多数对象都是朝生夕灭的
2. 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡
3. 跨代引用假说：跨代引用相对于同代引用来说仅占极少数

弱分代与强分代假说导致垃圾收集器将Java堆按照回收对象年龄段划分出不同存储区域：新生代和老年代，且经过多次垃圾收集后剩余存货的新生代对象因年龄增长而被转移到老年代中，jvm就可以兼顾垃圾收集的时间开销和内存空间的有效利用

因为划分出不同的垃圾回收区域，因此垃圾收集器针对部分区域的回收也出现了分类：**“Minor GC” “Major GC” “Full GC”**；针对不同存储对象存亡特征的区域，也存在相对应的垃圾收集算法：**标记-复制算法、标记-清除算法、标记-整理算法**

跨代引用假说提倡jvm不应为少量跨代引用而去扫描整个区域从而挑选出存在跨代引用的对象，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需要**建立一个全局的数据结构：记忆集，标识出哪一块内存存在跨代引用**

### 1. 标记-清除算法
首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象

**缺点**：
1. 执行效率不稳定，随着回收对象增多标记清除效率会低下
2. 标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作

<img src="D:\Project\IT notes\Java\JVM\img\标记-清除算法.png" style="width:700px;height:400px;" />

### 2. 标记-复制算法（适用于新生代）
将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉

<img src="D:\Project\IT notes\Java\JVM\img\标记-复制算法.png" style="width:700px;height:400px;" />

**一种更优化的半区复制分代策略，现在称为“Appel式回收”**：
	把新生代分为一块较大的`Eden`空间和两块较小的`Survivor`空间，每次分配内存只使用`Eden`和其中一块`Survivor`
	发生垃圾搜集时，将`Eden`和`Survivor`中仍然存活的对象一次性复制到另外一块`Survivor`空间上，然后直接清理掉`Eden`和已用过的那块`Survivor`空间
	HotSpot虚拟机默认`Eden`和`Survivor`的大小比例是8∶1，也即每次新生代中可用内存空间为整个新生代容量的90%（`Eden`的80%加上一个`Survivor`的10%），只有一个`Survivor`空间，即10%的新生代是会被“浪费”的
	当`Survivor`空间不足以容纳一次`Minor GC`之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保

### 3. 标记-整理算法（适用于老年代）
其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存

<img src="D:\Project\IT notes\Java\JVM\img\标记-整理算法.png" style="width:700px;height:400px;" />

*Stop The World：如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行*

## 6. 根节点枚举
固定可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中
所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的，因此毫无疑问根节点枚举与之前提及的整理内存碎片一样会面临相似的“Stop The World”的困扰

在进行垃圾收集，让用户线程停顿下来时，虚拟机应当是有办法直接得到哪些地方存放着对象引用的，而不需要扫描整个方法区与虚拟机栈中的引用位置

在HotSpot的解决方案里，是使用一组称为`OopMap`的数据结构来达到这个目的：一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。收集器在扫描时就可以从`OopMap`中获取而不需要从方法区或虚拟机栈中开始查找GC Roots节点

## 7. 安全点与安全区域
在`OopMap`的协助下，HotSpot可以快速准确地完成GC Roots枚举

在对象间引用关系随时变化的情况下，虚拟机只有在“特定的位置”才会改变`OopMap`，这些位置称为**安全点**，用户程序到达安全点后才会被强制要求暂停并开始垃圾收集

在垃圾收集时让所有线程都跑到最近的安全点停顿下来的方案：
1. 抢先式中断：不需要线程的执行代码主动去配合，在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上
2. 主动式中断：当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。轮询标志的地方和安全点是重合的

当线程没有被分配处理器时间导致无法在安全点中断，可以使用**安全区域**：能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的

## 8. 记忆集与卡表
为解决对象跨代引用所带来的问题，垃圾收集器在新生代中建立了名为**记忆集**（`Remembered Set`）的数据结构，用以避免把整个老年代加进`GC Roots`扫描范围

记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。在垃圾收集的场景中，收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针就可以了，并不需要了解这些跨代指针的全部细节

<img src="D:\Project\IT notes\Java\JVM\img\卡表与卡页.png" style="width:500px;height:700px;" />

一个卡页的内存中通常包含不止一个对象，只要卡页内有一个或更多对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为1，称为这个元素变脏，没有则标识为0。在垃圾收集发生时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把它们加入`GC Roots`中一并扫描

## 9. 写屏障
在HotSpot虚拟机里是通过写屏障技术维护卡表状态的，类似一个AOP切面产生环形通知提供额外的操作，在对象间引用关系出现变化的前后会出现写前屏障与写后屏障，通常jvm会在写后屏障更新卡表

## 10. 经典垃圾收集器
### 1. CMS
### 2. G1
