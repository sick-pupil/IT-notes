Java代码在编译后会变成Java字节码，字节码被类加载器加载到JVM里，JVM执行字节码，最终需要转化为汇编指令在CPU上执行

## 1. volatile
`volatile`是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。如果volatile变量修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度

**对volatile的定义如下**：Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量

**volatile实现过程**：如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条**Lock前缀的指令**，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里

**volatile的两个要点**：
- `Lock`前缀指令会引起处理器缓存回写到内存：`Lock`前缀指令导致在执行指令期间，声言处理器的LOCK#信号。在多处理器环境中，LOCK#信号确保在声言该信号期间，处理器可以独占任何共享内存。但是，在最近的处理器里，LOCK信号一般不锁总线，而是锁缓存，毕竟锁总线开销的比较大，如果访问的内存区域已经缓存在处理器内部，则不会声言LOCK#信号。相反，它会锁定这块内存区域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据
- 一个处理器的缓存回写到内存会导致其他处理器的缓存无效：处理器能嗅探其他处理器访问系统内存和它们的内部缓存。处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致。如果通过嗅探一个处理器来检测其他处理器打算写内存地址，而这个地址当前处于共享状态，那么正在嗅探的处理 器将使它的缓存行无效，在下次访问相同内存地址时，强制执行缓存行填充

## 2. synchronized
`synchronized`实现同步的基础：Java中的每一个对象都可以作为锁
- 对于普通同步方法，锁是当前实例对象
- 对于静态同步方法，锁是当前类的Class对象
- 对于同步方法块，锁是Synchonized括号里配置的对象

当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁
从JVM规范中可以看到Synchonized在JVM里的实现原理，JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。

代码块同步是使用`monitorenter`和`monitorexit`指令实现的，而方法同步是使用另外一种方式实现的：标识方法为`ACC_SYNCHRONIZED`

`monitorenter`指令是在编译后插入到同步代码块的开始位置，而`monitorexit`是插入到方法结束处和异常处，JVM要保证每个`monitorenter`必须有对应的`monitorexit`与之配对。任何对象都有一个`monitor`与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到`monitorenter`指令时，将会尝试获取对象所对应的`monitor`的所有权，即尝试获得对象的锁

<img src="D:\Project\IT-notes\Java\并发\img\对象头结构.png" style="width:750px;height:150px;" />

Java对象头里的`Mark Word`里默认存储对象的`HashCode`、分代年龄和锁标记位

<img src="D:\Project\IT-notes\Java\并发\img\markword结构.png" style="width:750px;height:200px;" />

## 3. Synchronized中的锁升级与锁对比
为了减少获得锁和释放锁带来的性能消耗，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率

### 1. 偏向锁
大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行`CAS`操作来加锁和解锁，只需简单地测试一下对象头的`Mark Word`里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下`Mark Word`中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用`CAS`将对象头的偏向锁指向当前线程

**偏向锁的撤销**：偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正 在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的`Mark Word`要么重新偏向于其他 线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程

<img src="D:\Project\IT-notes\Java\并发\img\偏向锁的获取与撤销过程.png" style="width:700px;height:800px;" />

### 2. 轻量级锁
**轻量级锁加锁**：线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并 将对象头中的`Mark Word`复制到锁记录中，官方称为`Displaced Mark Word`。然后线程尝试使用`CAS`将对象头中的`Mark Word`替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失 败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁

**轻量级锁解锁**：轻量级解锁时，会使用原子的`CAS`操作将`Displaced Mark Word`替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁

<img src="D:\Project\IT-notes\Java\并发\img\轻量级锁及膨胀流程.png" style="width:700px;height:700px;" />

因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争

## 4. 锁优缺点对比
<img src="D:\Project\IT-notes\Java\并发\img\锁的优缺点的对比.png" style="width:700px;height:220px;" />

## 5. 原子操作的实现原理
### 1. 使用总线锁保证原子性
如果多个处理器同时对共享变量进行读改写操作（i++就是经典的读改写操作），那么共享变量就会被多个处理器同时进行操作，这样读改写操作就不是原子的，操作完之后共享变量的值会和期望的不一致
所谓总线锁就是使用处理器提供的一个LOCK#信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存

### 2. 使用缓存锁保证原子性
在同一时刻，我们只需保证对某个内存地址的操作是原子性即可，但总线锁定把CPU和内存之间的通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，目前处理器在某些场合下使用缓存锁定代替总线锁定来进行优化
所谓“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效

***当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时，则处理器会调用总线锁定***

JDK的并发包里提供了一些类来支持原子操作，如`AtomicBoolean`（用原子方式更新的boolean值）、`AtomicInteger`（用原子方式更新的int值）和`AtomicLong`（用原子方式更新的long值）

**使用CAS实现原子操作存在三大问题：ABA问题；循环时间开销大；只能保证一个共享变量的原子操作**

#### ABA问题

<table>
	<tr>
		<td>T1</td>
		<td>X=A</td>
		<td>--</td>
		<td>线程1加入监控X</td>
	</tr>
	<tr>
		<td>T2</td>
		<td rowspan="4">复杂运算开始</td>
		<td>修改X=B</td>
		<td>线程2修改X，此刻为B</td>
	</tr>
	<tr>
		<td>T3</td>
		<td>处理简单业务</td>
		<td>--</td>
	</tr>
	<tr>
		<td>T4</td>
		<td>修改X=A</td>
		<td>线程2修改X，此刻又变回A</td>
	</tr>
	<tr>
		<td>T5</td>
		<td>结束线程2</td>
		<td>线程2结束</td>
	</tr>
	<tr>
		<td>T6</td>
		<td>检测X=A，验证通过，提交事务</td>
		<td>--</td>
		<td>CAS原理检测通过，因为和旧值保持一致</td>
	</tr>
</table>

例子：
1. 小琳在`ATM1`转账100块钱给小李
2. 由于`ATM1`出现了网络拥塞的原因卡住了，这时候小琳跑到旁边的`ATM2`再次操作转账
3. `ATM2`没让小琳失望，执行了`CAS(100,0)`，很痛快地完成了转账，此时小琳的账户余额为 0
4. 小王这时候又给小琳账上转了100，此时小琳账上余额为100
5. 这时候`ATM1`网络恢复，继续执行`CAS(100,0)`，居然执行成功了，小琳账户上余额又变为了 0
6. 这时候小王微信跟小琳说转了100过去，是否收到呢？小琳去查了下账，摇了摇头，那么问题来了，钱去了哪呢

**可以在原有CAS对共享变量判断基础上，添加使用递增的版本号或者时间戳**