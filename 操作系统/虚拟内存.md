## 1. 硬件和控制结构
把一个新进程放入内存时，操作系统仅读取包含程序开始处的一个或几个块。进程执行中的任何时候都在内存的部分称为进程的**常驻集**。当进程执行时，只要所有的内存访问都是要访问常驻集中的单元，执行就可以顺利进行

如果处理器需要访问一个不在内存中的逻辑地址，则产生一个中断，说明产生了内存访问故障。操作系统把被中断的进程置于阻塞态。为了能继续执行这个进程，操作系统必须把包含引发访问故障的逻辑地址的进程块读入内存。为此操作系统产生一个IO读请求。产生IO请求后，在执行磁盘IO期间，操作系统可以调度另一个进程运行。一旦需要的块被读入内存，则产生一个IO中断，控制交回给操作系统，而操作系统把由于缺少该块而被阻塞的进程置为就绪态

出现**常驻集**的优点：
1. **可在内存中保留多个进程**：由于对任何特定的进程都仅仅装入它的某些块。因此就有足够的空间来放置更多的进程
2. **进程可以比内存的全部空间还大**：通过基于分页或分段的虚拟内存，对于程序员而言，所处理的是一个巨大的内存，大小与磁盘存储器相关

**由于一个进程只能在内存中执行，因此这个存储器称为实存储器，简称实存。但是程序员或用户感觉到的是一个更大的内存，通常被分配在磁盘上，这称为虚拟内存**

<img src="D:\Project\IT notes\操作系统\img\简单分块与虚拟分块.png" style="width:700px;height:400px;" />

在任何时刻，任何一个进程只有一部分块位于内存中，可以在内存中保留更多的进程。此外，由于未用到的块不需要换入换出内存，因而节省了时间。当操作系统读取一块则必须把另一块换出，如果一块正好在将要被用到之前换出，操作系统不得不重新换入。这种现象称为**系统抖动**。而操作系统推断哪些块在将来被用到的可能是大是小都基于局部性原理：**一个进程中程序和数据引用的集簇倾向**

## 2. 分页
在简单分页中，每个进程都有自己的页表，当进程的所有页都被装入到内存中时，页表被创建且被装入内存。页表项包含有与内存中的页框相对应的页框号
在虚拟分页中，同样需要页表，并且通常每个进程都有一个唯一的页表，但页表结构相比简单分页要复杂

<img src="D:\Project\IT notes\操作系统\img\典型的内存管理格式.png" style="width:700px;height:350px;" />

由于一个进程只有一些页在内存中，因此每个页表项需要有一位P来表示它所对应的页当前是否在内存中。如果这一位表示该页在内存中，则这个页表项还包括该页的页框号
另一位控制位是修改位M，表示相应页的内容从上一次装入内存中到现在是否已经已经被修改。若修改过需要在换出时覆写到辅存中
页表项还提供了其他控制位，如提供控制保护或共享的

虚拟地址又称为逻辑地址，由页号和偏移量组成；物理地址由页框号和偏移量组成。由于页表大小与进程大小成正比，因此不能用寄存器存储页表，页表需载入内存中被访问

<img src="D:\Project\IT notes\操作系统\img\分页系统中的地址转换.png" style="width:700px;height:500px;" />

当一个特定的进程正在运行时，一个寄存器保存该进程页表的起始地址。虚拟地址的页号用于检索页表、查找相应的页框号，并与虚拟地址的偏移量组合起来产生需要实地址

由于内存中可以存放多个进程，而每个进程通常有一个页表与自身关联，因此会存在分配给页表的内存空间过大的问题，即**大型页表的内存空间问题**

### 多级页表
大多数虚拟内存方案都在虚存而非实存中保存页表，这意味着页表和其他页一样都服从分页管理。当一个进程正在运行时，它的页表至少有一部分必须在内存中，这一部分包括正在运行的页的页表项。基于此原理，可以使用**多级页表**

多级页表例：32位地址的两级页表方案

假设采用字节级寻址，页尺寸为4KB(2^12)，则4GB(2^32)虚拟地址空间由2^20页组成。若这些页中的每页都由一个4字节的页表项映射，则可创建由2^20个页表项组成的一个页表，这时需要4MB(2^22)的内存空间。这个由2^10页组成的巨大用户页表可以保存在虚存中，并由一个包括2^10个页表项的根页表映射，根页表占据的内存为4KB(2^12)

<img src="D:\Project\IT notes\操作系统\img\两级层次页表.png" style="width:500px;height:300px;" />

虚拟地址的前10位用于检索根页表，查找关于用户页表的页的页表项。若该页不在内存中，则发生一次缺页中断。若该页在内存中，则用虚拟地址中接下来的10位检索用户页表项页，查找该虚拟地址引用的页的页表项

<img src="D:\Project\IT notes\操作系统\img\两级分页系统中的地址转换.png" style="width:600px;height:400px;" />

### 倒排页表
多级页表存在”页表大小与虚拟地址空间大小成正比“的缺陷，因此可以使用**倒排页表**替代多级页表
虚拟地址的页号部分使用一个简单的散列函数映射到散列表中。散列表包含指向倒排表的指针，而倒排表中含有页表项。采用这种结构后，散列表和倒排表中就各有一项对应于一个实存页而非虚拟页（**倒排页表使用页框号而非虚拟页号来索引页表项**）。因此，不论有多少进程、支持多少虚拟页，页表都只需要实存中的一个固定部分。由于多个虚拟地址可能映射到同一个散列表项中，因此可以通过“链”管理这种散列冲突

<img src="D:\Project\IT notes\操作系统\img\倒排页表结构.png" style="width:500px;height:400px;" />

### 转换检测缓冲区
原则上，每次虚存访问都可能引起两次物理内存访问：一次取相应页表项，另一次取需要的数据
因此简单的虚拟内存方案会导致内存访问时间翻倍，使用**页表项的高速缓存**（也称为**转换检测缓冲区TLB**）可以解决这类问题

<img src="D:\Project\IT notes\操作系统\img\转换检测缓冲区的用法.png" style="width:500px;height:350px;" />

给定一个虚拟地址，处理器首先检查TLB，若需要的页表项在其中（TLB命中），则检索页框号并形成实地址。若未找到需要的页表项（TLB未命中），则处理器用页号检索进程页表，并检查相应的页表项。若“存在位P位”已置位，则该页在内存中，处理器从页表项中检索页框号以形成实地址。处理器同时更新TLB，使其包含这个新页表项。最后，若“存在位”未置位，则表示需要的页不在内存中，这时会产生一次内存访问故障，称为**缺页中断**。此时离开硬件作用范围，调用操作系统，由操作系统负责装入所需要的页，并更新页表

<img src="D:\Project\IT notes\操作系统\img\分页和转移检测缓冲区的操作.png" style="width:350px;height:500px;" />

<img src="D:\Project\IT notes\操作系统\img\页表项的直接查找和关联查找.png" style="width:500px;height:350px;" />

<img src="D:\Project\IT notes\操作系统\img\转换检测缓冲区和高速缓存操作.png" style="width:450px;height:450px;" />

单次内存访问中所涉及CPU硬件的复杂性。虚拟地址转换为实地址时，需要访问页表项，而页表项可能在TLB中，也可能在内存中或磁盘中，且被访问的字可能在高速缓存中、内存中或磁盘中。若被访问的字只在磁盘中，则包含该字的页必须装入内存，且它所在的块须装入高速缓存。此外，包含该字的页所对应的页表项必须更新

### 页尺寸导致的性能区别

## 3. 分段
**分段允许程序员把内粗你视为由多个地址空间或段组成，段的大小不等，并且是动态的。内存访问以段号和偏移量的形式组成地址**

在简单分段中，每个进程都有自己的段表，当一个进程的所有段都装入内存时，会为该进程创建一个段表并装入内存。每个段表项包含相应段在内存中的起始地址和段长度

在虚拟内存中的分段方案也需要段表的存在，且每个进程有自己唯一的段表。由于一个进程可能只有一部分段在内存中，因而每个段表项中需要一位**存在位**表明相应段是否在内存中，若该段在内存中，则这个段表项还包括该段的基址和段长度

段表项中也存在**修改位**，用于表明相应的段从上次被装入内存到目前为止其内容是否发生改变。若无改变，则该段从内存中被换出时不需要回写

虚拟内存中基于分段读取一个块的机制与简单分段类似，涉及使用段表将逻辑地址中的段号转换为段基址，段基址再与逻辑地址中的偏移量一并转换为物理地址，而段长度用于判断偏移量是否合法（段基址与偏移量相加得到的地址不得超过段基址与段长度相加结果，否则视为出界，产生内存访问故障）

<img src="D:\Project\IT notes\操作系统\img\分段系统中的地址转换.png" style="width:450px;height:350px;" />

## 4. 段页式
<img src="D:\Project\IT notes\操作系统\img\段页式系统中的地址转换.png" style="width:500px;height:350px;" />

## 5. 虚拟内存中的存储管理策略
<img src="D:\Project\IT notes\操作系统\img\虚拟内存的操作系统策略.png" style="width:700px;height:300px;" />

### 1. 读取策略
**读取策略决定某页何时取入内存**，常用的两种方法是**请求分页**和**预先分页**

- **请求分页**
只有当访问到某页中的一个单元时才将该页取入内存
例：当一个进程首次启动，会在一段时间出现大量的缺页中断；取入越来越多的页后，局部性原理表明大多数将来访问的页都是最近读取的页。因此一段时间后错误会逐渐减少，缺页中断的数量会降到很低

- **预先分页**
读取的页并不是缺页中断请求的页，预先分页利用了大多数辅存设备的特性。若一个进程的页连续存储在辅存中，则一次读取许多连续的页会更有效。若大多数额外读取的页在最近一段时间内未被引用，则这个策略是低效的
例：进程首次启动可采用预分页策略；发生缺页中断也可采用预先分页策略

### 2. 放置策略

### 3. 置换策略
读取一个新页时，往往会置换出内存中的另一页，置换策略需要考虑以下几个方面：
- 给每个活动进程分配多少页框
- 计划置换的页集是局限于产生缺页中断的进程，还是局限于所有页框都在内存中的进程
- 在计划置换的页集中，选择换出哪一页

当内存中的页框都被占据时，读取一个新页解决缺页中断的同时需要置换当前内存中的某一页。所有置换的目标都是移出最近最不可能访问的页（局部性原理）

**页框锁定**：置换策略存在一个约束条件，就是无法置换被锁定的页框。大部分操作系统内核和重要的控制结构就保存在锁定的页框中，此外还有IO缓冲区以及其他对时间要求严格的区域。通过给每个页框关联一个**锁位**实现

#### **置换策略的基本算法**
- **最佳（Optimal,OPT）**：选择置换下次访问距当前时间最长的页，要求操作系统必须知道将来的事件，因此不可能实现，可以作为衡量其他算法性能的一种标准
- **最近最少使用（Least Recently Used,LRU）**：选择置换内存中最长时间未被引用的页，根据局部性原理，也是最近最不可能访问到的页，实现方法可以是为每页添加一个最后一次访问的时间戳，并在每次访问内存时更新这个时间戳
- **先进先出（First In First Out,FIFO）**：把分配给进程的页框视为一个循环缓冲区，并按循环方式移动页，需要一个指针，指针在进程的页框中循环
- **时钟（Clock）**：给每个页框关联一个称为使用位的附加位。当某页首次装入内存时，将该页框的使用位置为1；该页随后被访问时（在访问产生缺页中断后），其使用位也会置为1。用于置换的候选页框集（页框集存在局部范围即当前进程，全局范围即整个内存）被视为一个循环缓冲区，并有一个指针与之相关联。当一页被置换，该指针被置为指向缓冲区中的下一个页框。需要置换一页时，扫描缓冲区，查找使用位为0的一个页框。每当遇到一个使用位为1的页框，就将该为置为0并跳过该页框扫描下一个页框，直到扫描到一个使用位为0的页框，置换该页框中的页
<img src="D:\Project\IT notes\操作系统\img\时钟策略的一个例子.png" style="width:600px;height:350px;" />

<img src="D:\Project\IT notes\操作系统\img\4种页面置换算法的行为.png" style="width:550px;height:350px;" />

对于时钟策略，若某页被修改，则在它被写回外存前不会被置换出，可分为四种情形：
1. 最近未被访问，也未被修改（u=0; m=0）
2. 最近被访问，但未被修改（u=1; m=0）
3. 最近未被访问，但被修改（u=0; m=1）
4. 最近被访问，且被修改（u=1; m=1）

时钟算法的执行过程如下：
1. 从指针的当前位置开始，扫描页框缓冲区。在这次扫描过程中，对使用位不做修改。选择遇到的第一个页框（u=0; m=0）用于置换
2. 若第1步失败，则重新扫描，查找（u=0; m=1）的页框。选择第一个遇到这种页框用于置换。在这一扫描过程中，将每个跳过的页框的使用位置为0
3. 若第2步失败，则指针回到其最初的位置，且集合中所有页框的使用位均为0。重复第1步，并在必要时重复第2步。这样便可找到供置换的页框

**页缓冲**：不丢弃置换出的页，而是将它分配到以下空闲页链表或修改页链表之一中。若未被修改，则分配到空闲页链表中；若已被修改，则分配到修改页链表中。注意，该页在内存中并不会物理性移动，移动的只是该页所对应的页表项，移动后的页表项放置在空闲页链表或修改页链表中
使用页缓冲，被置换的页仍然留在内存中。若进程访问该页，则可迅速返回该进程的驻留集，代价小。两种页链表充当着页的高速缓存角色。修改页链表可使已修改的页按簇写回，而不是一次只写一页，因此大大减少IO操作数量，进而减少了磁盘访问时间

### 4. 驻留集管理
驻留集大小：对于分页式虚拟内存，在准备执行时，不需要也不可能把一个进程的所有页都读入内存。因此必须决定读取多少页，即决定给特定的进程分配多大的内存空间，需考虑因素：
- 分配给一个进程的内存越少，在任何时候驻留在内存中的进程数就越多，增加了找到一个就绪进程的可能性，减少了由于交换而消耗的处理器时间
- 若一个进程在内存中的页数较少，尽管有局部性原理，缺页率会相对较高
- 给特定进程分配的内存空间超过一定大小，由于局部性原理，进程的缺页率无明显变化

**固定分配策略**：为一个进程在内存中分配固定数量的页框，在最初加载进程时确定
**可变分配策略**：允许分配给一个进程的页框在该进程的生命周期中不断变化

**局部置换范围**：仅在产生这次缺页的进程的驻留页中选择
**全局置换范围**：把内存中所有未被锁定的页都作为置换的候选页，不管属于哪个进程

<img src="D:\Project\IT notes\操作系统\img\驻留集管理.png" style="width:700px;height:150px;" />

### 5. 清除策略
清除策略用于确定何时将已修改的一页写回辅存

**请求式清除**：只有当一页被选择用于置换时才被写回辅存
**预约式清除**：将这些已修改的多页在需要使用它们所占据的页框之前成批写回辅存

对于预约式清除，写回辅存的一页可能仍然留在内存中，直到页面置换算法指示它被移出，但这些修改页可能在被置换前又被修改

对于请求式清除，写回已修改的一页和读入新页是成对出现的，且写回在读入之前，这意味着发生缺页中断的进程在解除阻塞之前必须等待两次页传送，可能降低处理器利用率

清除策略结合页缓冲是一种较好的方案

### 6. 加载控制