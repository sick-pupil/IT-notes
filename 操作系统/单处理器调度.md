## 1. 处理器调度类型
处理器调度的目的是，为满足系统目标的方式，把进程分配到一个或多个处理器上执行，可分为：长程调度、中程调度、短程调度

- **长程调度**：决定是否把进程添加到当前活跃的进程集中
- **中程调度**：属于交换功能的一部分，决定是否把进程添加到至少部分已在内存且被执行的进程集中
- **短程调度**：决定下次执行哪个就绪进程

<img src="D:\Project\IT notes\操作系统\img\调度与进程状态的关联.png" style="width:700px;height:500px;" />

<img src="D:\Project\IT notes\操作系统\img\调度队列图.png" style="width:500px;height:400px;" />

## 2. 选择调度策略
<img src="D:\Project\IT notes\操作系统\img\各种调度策略的特点.png" style="width:700px;height:320px;" />

<img src="D:\Project\IT notes\操作系统\img\进程调度示例.png" style="width:200px;height:150px;" />

<img src="D:\Project\IT notes\操作系统\img\调度策略的比较.png" style="width:400px;height:600px;" />

<img src="D:\Project\IT notes\操作系统\img\调度策略的比较2.png" style="width:700px;height:600px;" />

### 先来先服务FCFS
FCFS策略会在每个进程就绪后，将进程加入就绪队列。当前正运行的进程停止执行时，选择就绪队列中存在时间最长的进程运行
使用FCFS的缺点是当一个短进程跟在一个长进程后，会因为在内存中的等待时间过长导致完成时间相对较晚，因此FCFS策略对于短进程是不利的，但FCFS策略与优先级策略结合后通常能提供一种更有效的调度方法

### 轮转RR
RR策略会周期性地产生时钟中断，出现中断时，当前正运行的进程会放置到就绪队列中，然后基于FCFS策略选择下一个就绪作业运行（基于时钟的抢占策略），这种也称为时间片，因为每个进程在被抢占前都会给定一片时间
对于轮转法，主要的问题是所用的时间片长度，若长度很短，则短作业能相对较快通过系统，但另一方面过短的时间片会造成处理时钟中断、执行调度和分派函数的开销增大。因此时间片最好略大于一次典型交互的时间

基于简单轮转策略，还有一种**虚拟轮转法**：新进程根据FCFS管理到达并加入就绪队列，一个正运行进程用完时间片后，会返回就绪队列中。一个进程因IO而阻塞，会加入一个IO队列。当这些IO进程解除了IO阻塞都会转移到一个FCFS辅助队列，这个辅助队列进程的调度级别都优先于就绪队列中的进程

<img src="D:\Project\IT notes\操作系统\img\虚拟轮转调度排队图.png" style="width:350px;height:400px;" />

### 最短进程优先SPN
SPN策略会在下次调度时选择预计处理时间最短的进程，因此短进程会越过长进程。但只要持续不断地提供更短的进程，长进程就有可能饥饿，而且SPN缺少抢占机制

### 最短剩余时间SRT
SRT策略是在SPN策略上增加了抢占机制。SRT总是选择预期剩余时间最短的进程调度

### 最高响应比优先HRRN

### 反馈法
不存在各个进程相对长度的任何信息时，就不能使用SPN、SRT和HRRN。SPN、SRT和HRRN都需要预测进程的处理时间，而反馈法把重点放在关注进程已执行的时间上

反馈法调度基于抢占原则并使用动态优先级机制。一个进程首先进入系统并置于就绪队列RQ0。当每次被抢占并返回就绪态时，进程被置于RQi（0<i<n且等于被抢占的次数）。而队列之间的优先级，RQi>RQy（0<i<n,0<y<n,i<y）。因此每次被抢占后进程都会降级到下一低优先级的队列中。因此短进程和新进程会优于长进程和老进程，很快被执行完毕，而长进程和老进程会被多次降级。除优先级最低的队列外，其余队列都使用FCFS策略（也可使用轮转）。长进程和老进程被调度到RQn后（RQn优先级最低），不会再被降级，直至运行结束

<img src="D:\Project\IT notes\操作系统\img\多级反馈调度.png" style="width:350px;height:350px;" />

但是反馈策略会导致由于短进程和新进程的不断加入，长进程和老进程出现饥饿的情况。为解决这一问题：
1. 按照队列等级改变抢占次数，RQ0允许执行一个时间单位后被抢占，RQi（0<i<=n）允许执行2^i个时间单位后被抢占
2. 当一个进程在一个队列中超过一定的等待时间，则被提升到优先级较高的队列中