## 1. 死锁原理
可以把死锁定义为一组相互竞争系统资源或进行通信的进程间的永久阻塞。当一组进程中的每个进程都在等待某个事件，而只有在这组进程中的其他被阻塞的进程才可以触发该事件，这时就称这组进程发生死锁。因为没有事件能够被触发，故死锁是永久的

<img src="D:\Project\IT notes\操作系统\img\死锁示例.png" style="width:500px;height:500px;" />

<img src="D:\Project\IT notes\操作系统\img\无死锁示例.png" style="width:500px;height:500px;" />

## 2. 资源分类以及分配
**可重用资源**是指一次只能供一个进程安全地使用，并且不会由于使用而耗尽的资源。进程得到资源单元，后来又释放这些单元，供其他进程使用。例：处理器、IO通道、内存、外存、设备

**可消耗资源**是指可以被创建生产和销毁消耗的资源。通常对某种类型可消耗资源的数目没有限制，一个无阻塞的生产进程可以创建任意数目的这类资源。当消费进程得到一个资源时，该资源就不再存在了。例：中断、信号、消息和IO缓冲区

<img src="D:\Project\IT notes\操作系统\img\操作系统中死锁检测 预防和避免方法小结.png" style="width:700px;height:300px;" />

死锁存在三个必要条件：
1. **互斥**：一次只有一个进程可以使用一个资源，其他进程不能访问已分配给其他进程的资源
2. **占有且等待**：当一个进程等待其他进程时，继续占有已经分配的资源
3. **不可抢占**：不能强行抢占进程已占有的资源
三个必要条件造成潜在结果：**循环等待**

以上四个条件构成了所的充分必要条件

## 3. 死锁预防
死锁预防策略是试图设计一种系统来排除发生死锁的可能性。可以把死锁预防方法分为两类：间接的死锁预防方法，即防止前面列出的三个必要条件中的任何一个的发生；直接的死锁预防方法，即防止循环等待的发生

### 1. 互斥
这个条件不可能禁止。如果需要对资源进行互斥访问，那么操作系统必须支持互斥。某些资源如文件，可能允许多个读访问，但只能允许互斥的写访问，在这种情况下，如果有多个进程申请写权限，也可能发生死锁

### 2. 占有且等待
为预防占有且等待的条件，可以要求进程一次性请求所有需要的资源，并且阻塞这个进程直到所有请求都同时满足。这种方法在两个方面是低效的。首先，一个进程可能被阻塞很长时间，以等待满足其所有的资源请求。而实际上，只要有一部分资源，它就可以继续执行。其次，分配给一个进程的资源可能有相当长的一段时间不会被使用，在此期间，这些被分配的资源不能被其他进程使用。最后，一个进程可能事先不知道所需要的所有资源

### 3. 不可抢占
有几种方法预防这个条件：1. 如果占有某些资源的一个进程进一步申请资源时被拒绝，则该进程必须释放它最初占有的资源，如有必要，可再次申请资源 2. 如果一个进程请求当前被另一个进程占有的一个资源，则操作系统可以根据进程间的优先级要求进程释放资源

### 4. 循环等待
循环等待条件可以通过定义资源类型的线性顺序来预防。如果一个进程已经分配到了R类型的资源，那么接下来请求的资源只能是排在R类型之后的资源类型

## 4. 死锁避免
在死锁避免中，是否允许当前的资源分配请求是通过判断该请求是否可能导致死锁决定的

死锁避免的两种方法：
1. 如果一个进程的请求会导致死锁，则不启动此进程
2. 如果一个进程增加的资源请求会导致死锁，则不允许此分配

<img src="D:\Project\IT notes\操作系统\img\进程启动的最坏打算1.png" style="width:700px;height:350px;" />

<img src="D:\Project\IT notes\操作系统\img\进程启动的最坏打算2.png" style="width:700px;height:400px;" />

### 1. 银行家算法
<img src="D:\Project\IT notes\操作系统\img\死锁避免安全状态的确定.png" style="width:700px;height:350px;" />

当进程请求一组资源时，假设同意该请求，从而改变了系统的状态，然后确定其结果是否还处于安全状态。如果是，同意这个请求，如果不是，阻塞该进程直到同意该请求后系统状态仍然是安全的

死锁避免的优点：
1. 不需要死锁预防中的抢占和回滚进程，并且比死锁预防的限制少

死锁避免的缺点：
1. 必须事先声明每个进程请求的最大资源
2. 所讨论的进程必须是无关的，也就是说，它们执行的顺序必须没有任何同步要求的限制
3. 分配的资源数目必须是固定的
4. 在占有资源时，进程不能退出

## 5. 死锁检测
死锁预防策略非常保守，通过限制访问资源和在进程上强加约束来解决死锁问题。死锁检测策略则完全相反，不限制资源访问或约束进程行为。对于死锁检测，只要有可能，被请求的资源就被分配给进程

### 1. 死锁检测算法
死锁的检查可以非常频繁地在每个资源请求发生时进行，也可以进行得少一些，具体取决于发生死锁的可能性

<img src="D:\Project\IT notes\操作系统\img\死锁检测算法.png" style="width:700px;height:350px;" />

## 6. 死锁恢复
一旦检测到死锁，则需要某些策略恢复。按照递增复杂度列出以下恢复策略：
1. 取消所有的死锁进程。不管怎样，这是操作系统中最常采用的方法
2. 把每个死锁进程回滚到前面定义的某些检查点，并且重新启动所有进程。这要求在系统中构造回滚和重启机制。该方法的风险是原来的死锁可能再次发生
3. 连续取消死锁进程直到不再存在死锁
4. 连续抢占资源直到不再存在死锁