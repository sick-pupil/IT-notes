## 1. 背景
在单道程序设计系统中，内存被划分成两部分：一部分供操作系统使用（驻留监控程序、内核），一部分供当前正在执行的程序使用。在多道程序设计系统中，必须在内存中进一步细分出“用户”部分，以满足多个进程的要求。细分的任务由操作系统动态完成，此为**内存管理**

<img src="D:\Project\IT-notes\操作系统\img\内存管理术语.png" style="width:700px;height:120px;" />

## 2. 内存管理的需求
### 1. 重定位
通常情况下，程序员并不能事先知道在某个程序执行期间会有其他哪些程序驻留在内存中。此外还希望通过提供一个巨大的就绪进程池，能够把活动进程换入或换出内存，以便使处理器的利用率最大化。一旦程序被换出到磁盘，当下一次被换入时，需要把进程重定位到内存的不同区域

由于操作系统管理内存并负责把进程放入内存，因此可以容易地访问到这些地址。此外，处理器必须处理程序内部的内存访问。跳转指令包含下一步将要执行的指令的地址，数据访问指令包含有被访问数据的字节或字的地址。处理器硬件和操作系统软件必须能通过某种方式把程序代码中的内存访问转换成实际的物理内存地址

### 2. 保护
每个进程都应受到保护，以免被其他进程有意或无意干涉。一个进程以外的其他进程中的程序不能未经授权访问该进程的内存单元。通常用户进程不能访问操作系统的任何部分。

内存保护必须由处理器满足，因为操作系统不能预测程序可能产生的所有内存访问；即使可以预测但提前审查每个进程中可能存在的内存违法访问也是非常费时的，因此只能在指令访问内存时来判断这个内存访问是否违法

### 3. 共享
任何保护机制必须具有一定灵活性，以允许多个进程访问内存的同一部分

### 4. 逻辑组织
计算机系统中的内存总是被组织成线性地址空间，并且地址空间是由一系列字节或字组成。大多数程序被组织成模块

### 5. 物理组织

## 3. 内存分区
<img src="D:\Project\IT-notes\操作系统\img\内存管理技术分类.png" style="width:700px;height:400px;" />

### 1. 固定分区
假定操作系统占据内存中的某些固定部分，内存的其余部分可供多个用户进程使用。管理用户内存空间的最简单的方案是把内存分区，从而形成若干边界固定的区域

固定分区的两种选择：
1. **使用大小相等的分区**，小于或等于分区大小的任何进程都可以装入任何可用的分区。若分区满且没有进程处于就绪或运行态，则操作系统可以换出一个进程的所有分区并装入另一个进程
使用大小相等的分区存在**两个难点**：
- 程序太大而不能放到一个分区中，必须使用覆盖技术设计程序使得任何时候程序只有一部分需要放到内存中，需要的模块不在内存中则调入程序的分区中并覆盖
- 内存利用率低，即使程序很小也会占用一整个分区，从而产生内部碎片
2. **使用大小不等的分区**
使用大小不等的分区存在**两个难点**：
- 分区的数目在系统生成阶段已经确定，它限制了系统中活动进程的数目
- 由于分区大小是在系统生成阶段事先设置的，因而小作业不能有效利用分区空间

<img src="D:\Project\IT-notes\操作系统\img\固定分区两种分区策略.png" style="width:300px;height:600px;" />

#### 放置算法
- **对于大小相等的分区策略**：只要存在可用的分区，进程就可以装入分区，由于所有分区大小相等，因而使用哪个分区都没有关系。如果所有分区都被处于不可运行状态的进程所占据，那么这些进程中的一个必须被换出，从而为新进程让出空间
- **对于大小不等的分区策略**：
1. 把每个进程分配到能容纳它的最小分区中，每个分区维护一个调度队列，保存从这个分区换出的进程，然而会造成个别调度队列过长或过短
2. 所有分区共同维护一个调度队列，在当前空闲可用的分区中选择能容纳的最小分区分配给队列中的进程，若所有分区被占用，则会进行某些交换策略，如优先考虑换出能容纳新进程的最小分区中的进程，或者根据优先级进行换出，也可以优先考虑换出被阻塞的进程

<img src="D:\Project\IT-notes\操作系统\img\固定分区中的内存分配.png" style="width:400px;height:400px;" />

### 2. 动态分区
对于动态分区，分区长度和数目是可变的。当进程被装入内存时，系统会给它分配一块和它所需容量完全相等的内存空间

<img src="D:\Project\IT-notes\操作系统\img\动态分区的效果.png" style="width:400px;height:450px;" />

**动态分区的难点**：最终会导致在内存中出现许多小的空洞。随着时间的推移，内存中产生越来越多的**外部碎片**，内存利用率随之下降
克服动态分区产生外部碎片的一种解决方法是**压缩**。操作系统不时地移动进程，使得进程占用的空间连续，并且使所有空闲空间连续

#### 放置算法
由于压缩内存耗时，因而需要一定策略决定把进程换入或装入内存中的哪一部分，由此产生出三种放置算法：
1. **最佳适配**
2. **首次适配**
3. **下次适配**

所有这三种算法都是在内存中选择等于或大于该进程的空闲块，差别在于：
1. 最佳适配选择与要求的大小最接近的块
2. 首次适配从开始扫描内存，选择大小足够的第一个可用块
3. 下次适配从上一次放置的位置开始扫描内存，选择大小足够的第一个可用块

特点：
1. 最佳适配通常性能最差，这个算法需要查找满足要求的最小空闲块，可以保证产生的外部碎片尽可能小，但会产生很多细小的外部碎片，这些细小的外部碎片通常无法满足下次适配的空间大小要求，因此这种算法更需要多次内存压缩
2. 首次适配最简单，而且也比较快，但会使内存的前端产生较多的外部碎片
3. 下次适配会使内存末端产生较多的外部碎片

### 3. 伙伴系统
<img src="D:\Project\IT-notes\操作系统\img\伙伴系统示例.png" style="width:700px;height:450px;" />

<img src="D:\Project\IT-notes\操作系统\img\伙伴系统的树状表示.png" style="width:500px;height:450px;" />

### 4. 分页
假如内存被划分成大小固定相等的块，且块相对比较小，每个进程也被分成同样大小的小块，那么进程中称为页的块可以指定到内存中称为页框的可用块中。使用分页技术在内存中为每个进程浪费的空间，仅仅是进程最后一页的一小部分形成的内部碎片

<img src="D:\Project\IT-notes\操作系统\img\进程的空闲帧分配.png" style="width:500px;height:600px;" />

如图所示，进程的页可以加载入内存中不连续的页框。操作系统需要为每个进程维护一个页表，页表给出了该进程的每一页对应的页框的位置。在程序中，每个逻辑地址包括一个页号和在该页中的偏移量
- 在简单分区的情况下，逻辑地址是一个字相对于程序开始处的位置，处理器把它转换成一个物理地址
- 在分页中，逻辑地址到物理地址的转换仍然由处理器硬件完成，并且处理器必须知道如何访问当前进程的页表。给出逻辑地址（页号、偏移量），处理器使用页表产生物理地址（页框号、偏移量）

<img src="D:\Project\IT-notes\操作系统\img\页表示例.png" style="width:500px;height:150px;" />

每个页表项包含内存中的用于保存相应页的页框的页框号
采用分页技术的分区相当小，一个程序可以占据多个分区，并且这些分区不需要是连续的

<img src="D:\Project\IT-notes\操作系统\img\逻辑地址.png" style="width:500px;height:450px;" />

### 5. 分段
采用分段技术，可以把程序和其相关的数据划分到几个段中。尽管段有一个最大长度限制，但并不要求所有程序的所有段的长度都相等。和分页一样，采用分段技术时的逻辑地址也是由两部分组成的：段号和偏移量

分段方案中，一个程序可以占据多个分区，并且这些分区不要求是连续的。分段消除了内部碎片，但存在较小的外部碎片

采用大小不等的段的另一个结果是，逻辑地址和物理地址不再具有简单的对应关系。在简单分段方案中，每个进程都有一个段表，系统也会维护一个内存中的空闲块列表。每个段表项必须给出相应的段在内存中的起始地址，以及段的长度，以确保不会使用无效地址

例：
考虑一个n+m位的地址，最左边的n位是段号，最右边的m位是偏移量。进行地址转换需要以下步骤：
1. 提取段号，即逻辑地址最左边的n位
2. 以这个段号为索引，查找该进程段表中该段的起始物理地址
3. 最右边m位表示偏移量，偏移量和段长度进行比较，如果偏移量大于该段长度，则这个地址无效
4. 物理地址为该段的起始物理与偏移量的和

**采用简单分段技术，进程被划分为许多段，段的大小不需要相等；当一个进程被调入时，它的所有段都被装入内存的可用区域中，并建立一个段表**

## 4. 重定位
**逻辑地址**：指与当前数据在内存中的物理分配地址无关的访问地址，在执行对内存访问之前必须把它转换成物理地址
**相对地址**：逻辑地址的一个特例，是相对于某些已知点的存储单元
**物理地址**：数据在内存中的实际位置

进程在被换入换出以及发生内存压缩时，进程中的指令和数据单元位置都会发生变化。系统采用运行时动态加载的方式把使用相对地址的程序加载到内存。通常情况下，被加载进程中的所有内存访问都相对于程序的开始点。因此，在执行包括这类访问的指令时，需要一个硬件机制把相对地址转换成物理内存地址

<img src="D:\Project\IT-notes\操作系统\img\重定位的硬件支持.png" style="width:400px;height:450px;" />

当进程处于运行态时，一个特殊的处理器寄存器：**基址寄存器**，被载入程序在内存中的起始地址。还有一个**界限寄存器**指明程序的终止位置。当程序被装入内存或当该进程的映像被换入时，必须设置这两个寄存器。在进程的执行过程中会遇到相对地址，每个这样的相对地址都会经过两部操作：1. 基址寄存器的值加上相对地址产生一个绝对地址 2. 得到的绝对地址于界限寄存器值相比较。若绝对地址在界限地址范围内，则继续指令的执行，否则发出中断信号