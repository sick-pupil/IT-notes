## 1. RBAC设计模式
<img src="D:\Project\IT notes\技术要点\img\rbac设计模式.png" style="width:700px;height:400px;" />

<img src="D:\Project\IT notes\技术要点\img\rbac设计模式(1).png" style="width:700px;height:100px;" />

<img src="D:\Project\IT notes\技术要点\img\rbac-0.png" style="width:700px;height:100px;" />

<img src="D:\Project\IT notes\技术要点\img\rbac-1.png" style="width:700px;height:300px;" />

<img src="D:\Project\IT notes\技术要点\img\rbac-2.png" style="width:700px;height:300px;" />

## 2. Cookie、Session、Token
### 1. Cookie
Cookie指浏览器中永久存储的一种数据，是使用浏览器功能实现的一种数据存储方式
Cookie由服务器生成，发送给浏览器，浏览器将Cookie以key/value的形式保存到某个目录下的文本文件中，下一次请求同一网站会把该Cookie发送给服务器

### 2. Session
服务器在会话允许的情况下，默认采用Cookie给每个客户端分配不同的“标识ID”，随后在服务端内存中创建与该“标识ID”对应的唯一对象。每当客户端向服务器发送请求，都会带上该“标识ID”，服务器以此标识请求状态与请求用户身份

### 3. Token
所谓的Token，其实就是服务端生成的一串加密字符串、以作客户端进行请求的一个“令牌”。当用户第一次使用账号密码成功进行登录后，服务器便生成一个Token及Token失效时间并将此返回给客户端，若成功登陆，以后客户端只需在有效时间内带上这个Token前来请求数据即可，无需再次带上用户名和密码

工作流程：
1. 客户端使用用户名和密码请求登陆
2. 服务器收到请求，验证登陆是否成功验证成功后，服务器会返回一个token给客户端，反之，返回身份验证失败的信息
3. 客户端收到token后把token用一种方式存储起来，如（cookie，localstorage，sessionstorage，其他）  
4. 客户端每次发起请求时都会将token发给服务端
5. 服务端收到请求后，验证token的合法性，合法就返回客户端所需数据，反之，返回验证失败的信息

## 3. JWT与JJWT生成Token
jwt的token结构：header（头部）、payload（载荷）、signature（签名）

header头部信息结构：
```json
{
	"alg": "HS256", //用来说明这个JWT签发的时候所使用的签名和摘要算法
	"typ": "jwt" //用来标识整个token字符串是一个JWT字符串
}
```

payload载荷信息结构：
```json
{
	"sub": "1234567890", //sub代表这个token的所有人，存储的是所有人的ID
	"name": "john boe", //name表示这个所有人的名字
	"admin": true //admin表示所有人是否管理员的角色
}
```

| 属性 | 全称 | 描述 | 认证 |
| ----- | ----- | ----- | ----- |
| iss | Issuser | 代表签发主体 | 完全匹配 |
| sub | Subject | 代表的主体，它的所有人 | 完全匹配 |
| aud | Audience | 代表JWT的接收对象 | 包含即可 |
| exp | Expiration time | 代表这个JWT的过期时间 | 过期失败 |
| nbf | Not Before | 生效时间 | 早于该时间失败 |
| iat | Issued at | 签发时间，maxAge之类的验证 | 大于指定值失败 |
| jti | JWT ID | JWT的唯一标识 | 完全匹配 |

**其中header与payload部分需要做base64编码，生成各自的串后使用\“\.\”符号连接**

signature则是把以生成的 `header.payload` base64编码串和密钥一并加密得到

验证：把header做base64url解码，获取JWT签名算法，用该算法再次用同样的逻辑对header和payload做一次签名。获得的串与JWT本身的第三个部分的串比较。不同认为这个JWT被篡改过，验证失败了

#### JWT使用范例
```xml
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-api</artifactId>
    <version>0.10.7</version>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-impl</artifactId>
    <version>0.10.7</version>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-jackson</artifactId>
    <version>0.10.7</version>
    <scope>runtime</scope>
</dependency>
```

```java
public class JwtUtil { 
    private static Logger logger = Logger.getLogger(JwtUtil.class); 
    token的key 也是名 不要写成token这样，要按照规范来
    public static final String TOKEN_HEADER = "Authorization";
    token值的前缀，这是一种规范
    public static final String TOKEN_PREFIX = "Bearer ";
    加密时候用  是对称的秘钥盐
    private static final String SECRET = "mrLang";
    获取用户的功能使用的key
    public static final String FUNCTS = "FUNCTS";
    获取用户使用的key
    public static final String USERINFO = "USER";
    token的生命周期30分
    private static final long EXPIRATION = 1800L;
    /**
     * 创建token令牌 以下为参数都是自定义信息
     * @param loginName  一般我们放用户的唯一标识登录名
     * @param functs 当前用户的功能集合， 
     * 本人的rbac权限比较个性化且很负责，一般你们放role角色就可以了
     * @param user 当前用户
     * @return 
      */
    public static String createToken(String loginName, 
      List<Object> functs, Users user) {
        Map<String, Object> map = new HashMap<>(); //当前用户拥有的功能
        map.put(FUNCTS, JsonUtil.set(functs)); //当前用户信息
        map.put(USERINFO, JsonUtil.set(user));

        设置HS256加密，并且把你的盐 放里，这里推荐使用SH256证书加密

        String token = Jwts.builder()
                .setSubject(loginName)//主题  主角是谁？    赋值登录名
                .setClaims(map)
                .setIssuedAt(new Date())//设置发布时间，也是生成时间
                .setExpiration(new Date(System.currentTimeMillis() 
                  + EXPIRATION * 1000))//设置过期时间
                .signWith(SignatureAlgorithm.HS256, SECRET)
                .compact();//创建完成
        return token;
    }

	public static Claims getTokenBody(String token) { 
	  return Jwts.parser().setSigningKey(SECRET)
	            .parseClaimsJws(token).getBody();
	}

	public static boolean isExpiration(String token) {
		try { 
			return getTokenBody(token).getExpiration().before(new Date());
		} catch (Exception e) { 
			return true;
		}
	}

	// 获取主角，登录名
	public static String getUserName(String token) { 
	  return getTokenBody(token).getSubject();
	} 
	
	// 获取token中存储的功能
	public static List<Object> getUserFuncts(String token) {
	    String str = getTokenBody(token).get(FUNCTS).toString();
	    List<Object> list = JsonUtil.getArray(str); 
	    return list;
	} 
	
	// 获取token存储的用户
	public static Object getUser(String token) {
	    String str = getTokenBody(token).get(USERINFO).toString(); 
	    return JsonUtil.getObj(str);
	}

	public static String refreshToken(String token) { 
	  if (isExpiration(token)) {
	      logger.info("token刷新失败！！ 过期了！！"); return null;
	  } 
	
	  // 获取用户 权限信息
	  String functs = getTokenBody(token).get(FUNCTS).toString();
	  String user = getTokenBody(token).get(USERINFO).toString();
	  String username = getTokenBody(token).getSubject();
	  Map<String, Object> map = new HashMap<>();
	  map.put(FUNCTS, JsonUtil.set(functs));
	  map.put(USERINFO, JsonUtil.set(user));
	  token = Jwts.builder().signWith(SignatureAlgorithm.HS256, SECRET)
	     .setClaims(map).setSubject(username)
	     .setIssuedAt(new Date())
	     .setExpiration(new Date(System.currentTimeMillis() + EXPIRATION * 1000))
	     .compact(); 
	
		return token;
	}

	public static int verifyToken(String token) {
        try {
            Jwts.parser().setSigningKey(generateKey()).parseClaimsJws(token);
            return 0;
        } catch (ExpiredJwtException e) {
            e.printStackTrace();
            return 1;
        } catch (UnsupportedJwtException e) {
            e.printStackTrace();
            return 2;
        } catch (MalformedJwtException e) {
            e.printStackTrace();
            return 3;
        } catch (SignatureException e) {
            e.printStackTrace();
            return 4;
        } catch (IllegalArgumentException e) {
            e.printStackTrace();
            return 5;
        }
    }
}
```

## 4. Shiro
<img src="D:\Project\IT notes\技术要点\img\shiro核心架构.png" style="width:700px;height:400px;" />

1. Subject：主体，你可以理解为访问系统的用户
2. SecurityManager：安全管理器。用户进行认证和授权都是通过 securityManager 进行，你可以理解为 shiro 的老大
3. authenticator：认证器，用户通过 authenticator 进行认证
4. authorizer：授权器，用户通过 authorizer 进行授权
5. realm：领域，相当于数据源
	在 realm 中，我们通过查询数据库的信息，然后对用户进行认证和授权。所以 authenticator 和 authorizer 其实是调用了 realm 中 认证和授权的方法
6. cryptography：密码管理。shiro 提供了一套加密和解密的组件

#### SpringBoot整合Shiro
```xml
<dependency>
	<groupId>org.apache.shiro</groupId>
	<artifactId>shiro-spring-boot-starter</artifactId>
	<version>1.7.1</version>
</dependency>
```

```java
//用户登录注册成功后，存在针对密码加密的需求，即将明文密码加密存入数据库
public static final String md5Pwd(String salt, String pwd)
{
	//加密方式
	String hashAlgorithmName = "MD5";
	//盐：为了即使相同的密码不同的盐加密后的结果也不同
	ByteSource byteSalt = ByteSource.Util.bytes(salt);
	//加密次数
	int hashIterations = 2;
	SimpleHash result = new SimpleHash(hashAlgorithmName, pwd, byteSalt, hashIterations);
	return result.toString();
}
```

```java
public class CustomerRealm extends AuthorizingRealm 
{
    @Autowired
    private UserService userService;
    
    //授权认证
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection)
    {
        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();
        User user = (User) principalCollection.getPrimaryPrincipal();
        Integer userOid=user.getOid();
			
		//数据库交互	
        List<Role> roleList= userService.getRolesByUserOid(userOid);
        
        //用户角色
        Set<String> roleSet=new HashSet<>();
        //权限信息
        Set<String> funcSet=new HashSet<>();
        
        Set<Integer> roleOids=new HashSet<>();
        
        //查询角色
        if(roleList!=null && !roleList.isEmpty())
        {
            roleList.stream().forEach(t->{
                roleSet.add(String.valueOf(t.getRoleId()));
                roleOids.add(t.getOid());
            });
        }
        
        //查询权限
        List<Func> funcList= userService.getResByRoleOid(roleOids);
        if(funcList!=null && !funcList.isEmpty()){
            
            for(Func func:funcList)
            {
                funcSet.add(func.getUrl());
            }
        }
        
        //添加角色
        info.addRoles(roleSet);
        
        //添加权限
        info.addStringPermissions(funcSet);
        
        return info;
    }

    //用户认证
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(
            AuthenticationToken authToken) throws AuthenticationException
    {
        //采用用户名和密码方式
        UsernamePasswordToken usernamePasswordToken = (UsernamePasswordToken) authToken;
        String userId = usernamePasswordToken.getUsername();
        //密码
        String password = new String(usernamePasswordToken.getPassword());
        // 通过用户id获取用户信息
        User user = userService.getUserByUserId(userId);
        //认证。密码进行加密处理 
        SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(user, user.getPwd(),ByteSource.Util.bytes(user.getUserId()),getName());
        return info;
    }
}
```

```java
@Configuration
public class ShiroConfig
{
   // 自定义密码加密规则
    @Bean
    public HashedCredentialsMatcher hashedCredentialsMatcher()
    {
        HashedCredentialsMatcher hashedCredentialsMatcher =new HashedCredentialsMatcher();
        hashedCredentialsMatcher.setHashAlgorithmName("md5");
        hashedCredentialsMatcher.setHashIterations(2);
        //true 代表Hex编码，fasle代表采用base64编码
        hashedCredentialsMatcher.setStoredCredentialsHexEncoded(true);
        return hashedCredentialsMatcher;
    }
    
    // 自定义认证
    @Bean
    public CustomerRealm customerRealm()
    {
        CustomerRealm customerRealm=new  CustomerRealm();
        customerRealm.setCredentialsMatcher(hashedCredentialsMatcher());
        customerRealm.setCachingEnabled(false);
        return customerRealm;
    }
    
    //需要定义DefaultWebSecurityManager，否则会报bean冲突
    @Bean
    public DefaultWebSecurityManager securityManager() 
    {
        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();
        securityManager.setRealm(customerRealm());
        securityManager.setRememberMeManager(null);
        return securityManager;
    }
    
    @Bean
    public ShiroFilterFactoryBean shiroFilterFactoryBean(DefaultWebSecurityManager securityManager)
    {
        ShiroFilterFactoryBean factoryBean = new ShiroFilterFactoryBean();
        //给filter设置安全管理
        factoryBean.setSecurityManager(securityManager);
        
        //配置系统的受限资源
        Map<String,String> map = new HashMap<>();
        //登录请求无需认证
        map.put("/login", "anon");
        //其他请求需要认证
        map.put("/**", "authc");
        
        //访问需要认证的页面如果未登录会跳转到/login
        factoryBean.setLoginUrl("/login");
        //访问未授权页面会自动跳转到/unAuth
        factoryBean.setUnauthorizedUrl("/unAuth");
        factoryBean.setFilterChainDefinitionMap(map);
        return factoryBean;
    }
    
    
    /**
     * 开启注解方式，页面可以使用注解
     * @param securityManager
     * @return
     */
    @Bean
    public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) {
        AuthorizationAttributeSourceAdvisor advisor = new AuthorizationAttributeSourceAdvisor();
        advisor.setSecurityManager(securityManager);
        return advisor;
    }
}
```

#### SpringBoot+Shiro+JWT
```java
package cn.pconline.config.auth;

import lombok.Data;
import org.apache.shiro.authc.AuthenticationToken;

/**
 * @Description JwtToken 传输类
 * @Author jie.zhao
 * @Date 2019/8/7 10:45
 */
@Data
public class JwtToken implements AuthenticationToken {

    private static final long serialVersionUID = 1282057025599826155L;

    private String token;

    private String exipreAt;

    public JwtToken(String token) {
        this.token = token;
    }

    public JwtToken(String token, String exipreAt) {
        this.token = token;
        this.exipreAt = exipreAt;
    }

    @Override
    public Object getPrincipal() {
        return token;
    }

    @Override
    public Object getCredentials() {
        return token;
    }

}
```

```java
package cn.pconline.config.auth;

import com.auth0.jwt.JWT;
import com.auth0.jwt.JWTVerifier;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.exceptions.JWTDecodeException;
import com.auth0.jwt.exceptions.JWTVerificationException;
import com.auth0.jwt.interfaces.DecodedJWT;

import java.util.Date;

/**
 * @Description Jwt工具类
 * @Author jie.zhao
 * @Date 2019/8/7 10:59
 */
public class JwtUtil {

    /**
     * 过期时间30分钟，这里需要根据具体的需求来
     */
    private static final long EXPIRE_TIME = 30 * 60 * 1000;

    /**
     * 校验token是否正确
     *
     * @param token    密钥
     * @param username 用户名
     * @param secret   用户的密码
     * @return 正确: true；不正确：false
     */
    public static boolean verify(String token, String username, String secret) {
        // 根据密码生成JWT校验器
        try {
            Algorithm algorithm = Algorithm.HMAC256(secret);
            JWTVerifier verifier = JWT.require(algorithm)
                    .withClaim("username", username)
                    .build();
            // 校验TOKEN
            DecodedJWT jwt = verifier.verify(token);
            return true;
        } catch (IllegalArgumentException e) {
            e.printStackTrace();
            return false;
        } catch (JWTVerificationException e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 获取用户名
     *
     * @param token token中包含了用户名
     * @return
     */
    public static String getUsername(String token) {
        try {
            DecodedJWT jwt = JWT.decode(token);
            return jwt.getClaim("username").asString();
        } catch (JWTDecodeException e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * 生成签名
     *
     * @param username 用户名
     * @param secret   密码
     * @return 加密的TOKEN
     */
    public static String sign(String username, String secret) {
        Date date = new Date(System.currentTimeMillis() + EXPIRE_TIME);
        Algorithm algorithm = Algorithm.HMAC256(secret);
        // 附带用户信息
        return JWT.create()
                .withClaim("username", username)
                .withExpiresAt(date)
                .sign(algorithm);
    }
}
```

```java
package cn.pconline.config.auth;

import cn.pconline.modules.sys.entity.SysUser;
import cn.pconline.modules.sys.service.SysUserService;
import org.apache.commons.lang3.StringUtils;
import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.AuthenticationInfo;
import org.apache.shiro.authc.AuthenticationToken;
import org.apache.shiro.authc.SimpleAuthenticationInfo;
import org.apache.shiro.authz.AuthorizationInfo;
import org.apache.shiro.authz.SimpleAuthorizationInfo;
import org.apache.shiro.realm.AuthorizingRealm;
import org.apache.shiro.subject.PrincipalCollection;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.Set;

/**
 * @Description  自定义实现 ShiroRealm，包含认证和授权两大模块
 * @Author jie.zhao
 * @Date 2019/8/13 11:19 
 */
public class MyRealm extends AuthorizingRealm {

    @Autowired
    private SysUserService userService;

    /**
     * 必须重写此方法，不然Shiro会报错
     */
    @Override
    public boolean supports(AuthenticationToken token) {
        return token instanceof JwtToken;
    }

    /**
     * 授权模块，获取用户角色和权限
     * 只有当需要检测用户权限的时候才会调用此方法，例如checkRole,checkPermission之类的
     */
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
        String username = JwtUtil.getUsername(principals.toString());
        SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo();
        // 获取用户角色集
        Set<String> roleSet = userService.getUserRoles(username);
        simpleAuthorizationInfo.setRoles(roleSet);
        // 获取用户权限集
        Set<String> permissionSet = userService.getUserPermissions(username);
        simpleAuthorizationInfo.setStringPermissions(permissionSet);
        return simpleAuthorizationInfo;
    }

    /**
     * 用户认证
     * 默认使用此方法进行用户名正确与否验证，错误抛出异常即可。
     * @param authenticationToken 身份认证 token
     * @return AuthenticationInfo 身份认证信息
     * @throws AuthenticationException 认证相关异常
     */
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {
        // 这里的 token是从 JwtFilter 的 executeLogin 方法传递过来的，已经经过了解密
        String token = (String) authenticationToken.getCredentials();
        String username = JwtUtil.getUsername(token);
        if (StringUtils.isBlank(username)) {
            throw new AuthenticationException("token校验不通过");
        }
        // 如果要实现登出逻辑需要将用户和token存储起来（redis、memcache等）这里校验token是否有效
        
        // 通过用户名查询用户信息，也可改为接口验证用户名是否存在（即通过登录中心验证的）
        SysUser user = userService.getUser(username);
        if (user == null) {
            throw new AuthenticationException("用户名或密码错误");
        }
        /*
         * 注意这里的校验
         * token
 * 
         * username 用户名
         * secret 用户的密码
         *
         * 这里要注意secret这个字段，如果本地系统没有用户存储用户密码（即通过登录中心验证的）
         * 可以把这个值写成一个固定值，当然这样有一定的风险，或者根据一定的规则生成假的密码来验证。
         *
         */
        if (!JwtUtil.verify(token, username, user.getPassword())) {
            throw new AuthenticationException("token校验不通过");
        }
        return new SimpleAuthenticationInfo(token, token, "my_realm");
    }
}
```

```java
package cn.pconline.config.auth;

import cn.pconline.config.authentication.JwtToken;
import lombok.extern.slf4j.Slf4j;
import org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.RequestMethod;

import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * @Description Jwt过滤器
 * @Author jie.zhao
 * @Date 2019/8/7 10:47
 */
@Slf4j
public class JwtFilter extends BasicHttpAuthenticationFilter {

    private static final String TOKEN = "Authentication";

    /**
     * 判断用户是否想要登入。
     * 检测header里面是否包含Authorization字段即可
     */
    @Override
    protected boolean isLoginAttempt(ServletRequest request, ServletResponse response) {
        HttpServletRequest req = (HttpServletRequest) request;
        String authorization = req.getHeader(TOKEN);
        return authorization != null;
    }

    /**
     *
     */
    @Override
    protected boolean executeLogin(ServletRequest request, ServletResponse response) throws Exception {
        HttpServletRequest httpServletRequest = (HttpServletRequest) request;
        String authorization = httpServletRequest.getHeader(TOKEN);

        JwtToken token = new JwtToken(authorization);
        // 提交给realm进行登入，如果错误他会抛出异常并被捕获
        getSubject(request, response).login(token);
        // 如果没有抛出异常则代表登入成功，返回true
        return true;
    }

    /**
     * 这里我们详细说明下为什么最终返回的都是true，即允许访问
     * 例如我们提供一个地址 GET /article
     * 登入用户和游客看到的内容是不同的
     * 如果在这里返回了false，请求会被直接拦截，用户看不到任何东西
     * 所以我们在这里返回true，Controller中可以通过 subject.isAuthenticated() 来判断用户是否登入
     * 如果有些资源只有登入用户才能访问，我们只需要在方法上面加上 @RequiresAuthentication 注解即可
     * 但是这样做有一个缺点，就是不能够对GET,POST等请求进行分别过滤鉴权(因为我们重写了官方的方法)，但实际上对应用影响不大
     */
    @Override
    protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) {
        if (isLoginAttempt(request, response)) {
            try {
                executeLogin(request, response);
            } catch (Exception e) {
                response401(request, response);
            }
        }
        return true;
    }

    /**
     * 对跨域提供支持
     */
    @Override
    protected boolean preHandle(ServletRequest request, ServletResponse response) throws Exception {
        HttpServletRequest httpServletRequest = (HttpServletRequest) request;
        HttpServletResponse httpServletResponse = (HttpServletResponse) response;
        httpServletResponse.setHeader("Access-control-Allow-Origin", httpServletRequest.getHeader("Origin"));
        httpServletResponse.setHeader("Access-Control-Allow-Methods", "GET,POST,OPTIONS,PUT,DELETE");
        httpServletResponse.setHeader("Access-Control-Allow-Headers", httpServletRequest.getHeader("Access-Control-Request-Headers"));
        // 跨域时会首先发送一个option请求，这里我们给option请求直接返回正常状态
        if (httpServletRequest.getMethod().equals(RequestMethod.OPTIONS.name())) {
            httpServletResponse.setStatus(HttpStatus.OK.value());
            return false;
        }
        return super.preHandle(request, response);
    }

    /**
     * 将非法请求跳转到 /401
     */
    private void response401(ServletRequest req, ServletResponse resp) {
        try {
            HttpServletResponse httpServletResponse = (HttpServletResponse) resp;
            httpServletResponse.sendRedirect("/401");
        } catch (IOException e) {
            log.error(e.getMessage());
        }
    }
}
```

```java
package cn.pconline.config.auth;

import cn.pconline.config.authentication.JwtFilter;
import org.apache.shiro.mgt.DefaultSessionStorageEvaluator;
import org.apache.shiro.mgt.DefaultSubjectDAO;
import org.apache.shiro.mgt.SecurityManager;
import org.apache.shiro.spring.LifecycleBeanPostProcessor;
import org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor;
import org.apache.shiro.spring.web.ShiroFilterFactoryBean;
import org.apache.shiro.web.mgt.DefaultWebSecurityManager;
import org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.DependsOn;

import javax.servlet.Filter;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 * @Description Shiro 配置类
 * @Author jie.zhao
 * @Date 2019/8/7 11:02
 */
@Configuration
public class ShiroConfig {

    @Bean
    public SecurityManager securityManager() {
        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();
        // 配置 SecurityManager，并注入 shiroRealm
        securityManager.setRealm(myRealm());

        /*
         * 关闭shiro自带的session，详情见文档
         * http://shiro.apache.org/session-management.html#SessionManagement-StatelessApplications%28Sessionless%29
         */
        DefaultSubjectDAO subjectDAO = new DefaultSubjectDAO();
        DefaultSessionStorageEvaluator defaultSessionStorageEvaluator = new DefaultSessionStorageEvaluator();
        defaultSessionStorageEvaluator.setSessionStorageEnabled(false);
        subjectDAO.setSessionStorageEvaluator(defaultSessionStorageEvaluator);
        securityManager.setSubjectDAO(subjectDAO);
        return securityManager;
    }

    @Bean
    public MyRealm myRealm() {
        // 配置 Realm
        return new MyRealm();
    }

    @Bean
    public ShiroFilterFactoryBean shiroFilterFactoryBean(SecurityManager securityManager) {
        ShiroFilterFactoryBean factoryBean = new ShiroFilterFactoryBean();

        // 添加自己的过滤器并且取名为jwt
        LinkedHashMap<String, Filter> filters = new LinkedHashMap<>();
        filters.put("jwt", new JwtFilter());
        factoryBean.setFilters(filters);

        factoryBean.setSecurityManager(securityManager);
        factoryBean.setUnauthorizedUrl("/401");

        /*
         * 自定义url规则
         * http://shiro.apache.org/web.html#urls-
         */
        Map<String, String> filterRuleMap = new HashMap<>();
        // 所有请求通过我们自己的JWT Filter
        filterRuleMap.put("/**", "jwt");
        // 访问401和404页面不通过我们的Filter
        filterRuleMap.put("/401", "anon");
        factoryBean.setFilterChainDefinitionMap(filterRuleMap);
        return factoryBean;
    }

    /**
     * 下面的代码是添加注解支持
     */
    @Bean
    @DependsOn("lifecycleBeanPostProcessor")
    public DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator() {
        DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator = new DefaultAdvisorAutoProxyCreator();
        // 强制使用cglib，防止重复代理和可能引起代理出错的问题
        // https://zhuanlan.zhihu.com/p/29161098
        defaultAdvisorAutoProxyCreator.setProxyTargetClass(true);
        return defaultAdvisorAutoProxyCreator;
    }

    @Bean
    public LifecycleBeanPostProcessor lifecycleBeanPostProcessor() {
        return new LifecycleBeanPostProcessor();
    }

    @Bean
    public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(DefaultWebSecurityManager securityManager) {
        AuthorizationAttributeSourceAdvisor advisor = new AuthorizationAttributeSourceAdvisor();
        advisor.setSecurityManager(securityManager);
        return advisor;
    }
}
```

```java
/login
登入

/article
所有人都可以访问，但是用户与游客看到的内容不同

/require_auth
登入的用户才可以进行访问

/require_role
admin的角色用户才可以登入

/require_permission
拥有view和edit权限的用户才可以访问 


@RestController
public class WebController {

    private static final Logger LOGGER = LogManager.getLogger(WebController.class);

    private UserService userService;

    @Autowired
    public void setService(UserService userService) {
        this.userService = userService;
    }

    @PostMapping("/login")
    public ResponseBean login(@RequestParam("username") String username,
                              @RequestParam("password") String password) {
         // 通过用户名查询用户信息，也可改为接口验证用户名是否存在（即通过登录中心验证的） 
        UserBean userBean = userService.getUser(username);
        if (userBean.getPassword().equals(password)) {
            return new ResponseBean(200, "Login success", JWTUtil.sign(username, password));
        } else {
            throw new UnauthorizedException();
        }
    }

    @GetMapping("/article")
    public ResponseBean article() {
        Subject subject = SecurityUtils.getSubject();
        if (subject.isAuthenticated()) {
            return new ResponseBean(200, "You are already logged in", null);
        } else {
            return new ResponseBean(200, "You are guest", null);
        }
    }

    @GetMapping("/require_auth")
    @RequiresAuthentication
    public ResponseBean requireAuth() {
        return new ResponseBean(200, "You are authenticated", null);
    }

    @GetMapping("/require_role")
    @RequiresRoles("admin")
    public ResponseBean requireRole() {
        return new ResponseBean(200, "You are visiting require_role", null);
    }

    @GetMapping("/require_permission")
    @RequiresPermissions(logical = Logical.AND, value = {"view", "edit"})
    public ResponseBean requirePermission() {
        return new ResponseBean(200, "You are visiting permission require edit,view", null);
    }

    @RequestMapping(path = "/401")
    @ResponseStatus(HttpStatus.UNAUTHORIZED)
    public ResponseBean unauthorized() {
        return new ResponseBean(401, "Unauthorized", null);
    }
} 
 

```

## 5. SpringSecurity
<img src="D:\Project\IT notes\技术要点\img\认证过程.jpg" style="width:700px;height:400px;" />

<img src="D:\Project\IT notes\技术要点\img\权限流程.jpg" style="width:700px;height:400px;" />

#### SpringSecurity基本配置
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```
**添加依赖后，会根据依赖的自动配置类添加默认配置**；添加了SpringSecurity依赖后，所有接口都会被保护认证，未登录则跳转到默认SpringSecurity的登录页，默认用户名是user，登录密码每次项目启动会随机生成，在启动日志中会打印出来

SpringSecurity的登录接口数据结构必须存在：username、password、remember-me

默认用户名与登录密码可自定义配置
```yml
spring:
	security:
		user:
			name:user
			password:123
			roles:admin
```

登录认证配置：
```java
/**
* 默认情况下不需要开发者自己进行密码角色等信息的比对，开发者只需要提供相关信息即可，例如：
	getPassword() 方法返回的密码和用户输入的登录密码不匹配，会自动抛出 BadCredentialsException 异常
	isAccountNonLocked() 方法返回了 false，会自动抛出 AccountExpiredException 异常
**/
public class User implements UserDetails {

    private Integer id;
    
    private String userName;
    
    private String password;
    
    private boolean enable;
    
    private boolean locked;

    private List<Role> userRoles;

	//获取当前用户对象所具有的角色信息
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        List<SimpleGrantedAuthority> authorities = new ArrayList<>();
        for (Role role : userRoles) {
            authorities.add(new SimpleGrantedAuthority(role.getName()));
        }
        return authorities;
    }

	//获取当前用户对象的用户名
    @Override
    public String getUsername() {
        return userName;
    }

	//当前账户是否未过期
    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

	//当前账户是否未锁定
    @Override
    public boolean isAccountNonLocked() {
        return !locked;
    }

	//当前账户密码是否未过期
    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return enable;
    }

    public void setPassword(String password) {
        this.password = password;
    }

	//获取当前用户对象的密码
    public String getPassword() {
        return password;
    }

    public boolean isEnable() {
        return enable;
    }

    public void setEnable(boolean enable) {
        this.enable = enable;
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getUserName() {
        return userName;
    }

    public void setUserName(String userName) {
        this.userName = userName;
    }

    public boolean isLocked() {
        return locked;
    }

    public void setLocked(boolean locked) {
        this.locked = locked;
    }

    public List<Role> getUserRoles() {
        return userRoles;
    }

    public void setUserRoles(List<Role> userRoles) {
        this.userRoles = userRoles;
    }
}
```

```java
@Service
public class UserService implements UserDetailsService {
    @Autowired
    private UserMapperDao userMapperDao;
    @Autowired
    private PasswordEncoder passwordEncoder;

	//该方法在用户登录认证时自动调用
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userMapperDao.loadUserByUsername(username);
          if (user == null) {
            throw new UsernameNotFoundException("账户不存在!");
        }
         // 我的数据库用户密码没加密，这里手动设置
        String encodePassword = passwordEncoder.encode(user.getPassword());
        System.out.println("加密后的密码：" + encodePassword);
        user.setPassword(encodePassword);
        List<Role> userRoles = userMapperDao.getUserRolesByUid(user.getId());
        user.setUserRoles(userRoles);
        return user;
    }
}
```

```java
@Configuration
@EnableWebSecurity
public class MyWebSecurityConfig extends WebSecurityConfigurerAdapter
{ 
	
	@Autowired
	private UserDetailService userService;
	
	// 指定密码的加密方式    
	@Bean    
	public PasswordEncoder passwordEncoder() {
		// 使用BCrypt强哈希函数加密方案，密钥迭代次数设为10（默认即为10）
        return new BCryptPasswordEncoder(10);   
	}
	
	// 配置用户及其对应的角色
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception
	{
		/**
			auth.inMemoryAuthentication()
	        .withUser("root").password("123").roles("ADMIN","DBA")
	        .and()
	        .withUser("admin").password("123").roles("ADMIN","USER")
	        .and()
	        .withUser("hangge").password("123").roles("USER");
		**/
		auth.userDetailService(userService).passwordEncoder(passwordEncoder());
	} 
        
    // 配置 URL 访问权限
    @Override
    protected void configure(HttpSecurity http) throws Exception
    {
	    http.exceptionHanding().accessDeniedPage("/unauth.html"); //定义403无认证返回页面
        http.authorizeRequests() // 开启 HttpSecurity 配置
            .antMatchers("/admin/**").hasRole("ADMIN") // admin/** 模式URL必须具备ADMIN角色
            .antMatchers("/user/**").access("hasAnyRole('ADMIN','USER')") // 该模式需要ADMIN或USER角色
            .antMatchers("/db/**").access("hasRole('ADMIN') and hasRole('DBA')") // 需ADMIN和DBA角色
            .anyRequest().authenticated() // 用户访问其它URL都必须认证后访问（登录后访问）
            .and().formLogin().loginProcessingUrl("/login").permitAll() // 开启表单登录并配置登录接口
            .and().csrf().disable(); // 关闭csrf
    /**动态权限
	    http.authorizeRequests()
	        .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {
				@Override
				public <O extends FilterSecurityInterceptor> O postProcess(O object) {
					object.setSecurityMetadataSource(accessMustRoles());
					object.setAccessDecisionManager(rolesCheck());
					return object;
				}
			})
			.and().formLogin().loginProcessingUrl("/login").permitAll()//开启表单登录并配置登录接口
			.and().csrf().disable(); // 关闭csrf
    }
	
	@Bean
    public CustomFilterInvocationSecurityMetadataSource accessMustRoles() {
        return new CustomFilterInvocationSecurityMetadataSource();
    }

    @Bean
    public CustomAccessDecisionManager rolesCheck() {
        return new CustomAccessDecisionManager();
    }
    **/
}
```

一些比较详细的SpringSecurity配置（登录成功处理器、登录失败处理器、注销登录处理器）：
```java
@Configuration
public class MyWebSecurityConfig extends WebSecurityConfigurerAdapter {
    // 指定密码的加密方式
    @SuppressWarnings("deprecation")
    @Bean
    PasswordEncoder passwordEncoder(){
        // 不对密码进行加密
        return NoOpPasswordEncoder.getInstance();
    }
 
    // 配置用户及其对应的角色
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.inMemoryAuthentication()
                .withUser("root").password("123").roles("DBA")
                .and()
                .withUser("admin").password("123").roles("ADMIN")
                .and()
                .withUser("hangge").password("123").roles("USER");
    }
 
    // 配置 URL 访问权限
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests() // 开启 HttpSecurity 配置
            .antMatchers("/db/**").hasRole("DBA") // db/** 模式URL需DBA角色
            .antMatchers("/admin/**").hasRole("ADMIN") // admin/** 模式URL需ADMIN角色
            .antMatchers("/user/**").hasRole("USER") // user/** 模式URL需USER角色
            .anyRequest().authenticated() // 用户访问其它URL都必须认证后访问（登录后访问）
            .and().formLogin()  // 开启登录表单功能
            .loginPage("/login_page") // 使用自定义的登录页面，不再使用SpringSecurity提供的默认登录页
            .loginProcessingUrl("/login") // 配置登录请求处理接口，自定义登录页面、移动端登录都使用该接口
            .usernameParameter("name") // 修改认证所需的用户名的参数名（默认为username）
            .passwordParameter("passwd") // 修改认证所需的密码的参数名（默认为password）
            // 定义登录成功的处理逻辑（可以跳转到某一个页面，也可以返会一段 JSON）
            .successHandler(new AuthenticationSuccessHandler() {
                @Override
                public void onAuthenticationSuccess(HttpServletRequest req,
                                                    HttpServletResponse resp,
                                                    Authentication auth)
                        throws IOException, ServletException {
                    // 我们可以跳转到指定页面
                    // resp.sendRedirect("/index");
  
                    // 也可以返回一段JSON提示
                    // 获取当前登录用户的信息，在登录成功后，将当前登录用户的信息一起返回给客户端
                    Object principal = auth.getPrincipal();
                    resp.setContentType("application/json;charset=utf-8");
                    PrintWriter out = resp.getWriter();
                    resp.setStatus(200);
                    Map<String, Object> map = new HashMap<>();
                    map.put("status", 200);
                    map.put("msg", principal);
                    ObjectMapper om = new ObjectMapper();
                    out.write(om.writeValueAsString(map));
                    out.flush();
                    out.close();
                }
            })
            // 定义登录失败的处理逻辑（可以跳转到某一个页面，也可以返会一段 JSON）
            .failureHandler(new AuthenticationFailureHandler() {
                @Override
                public void onAuthenticationFailure(HttpServletRequest req,
                                                    HttpServletResponse resp,
                                                    AuthenticationException e)
                        throws IOException, ServletException {
                    resp.setContentType("application/json;charset=utf-8");
                    PrintWriter out = resp.getWriter();
                    resp.setStatus(401);
                    Map<String, Object> map = new HashMap<>();
                    // 通过异常参数可以获取登录失败的原因，进而给用户一个明确的提示。
                    map.put("status", 401);
                    if (e instanceof LockedException) {
                        map.put("msg", "账户被锁定，登录失败!");
                    }else if(e instanceof BadCredentialsException){
                        map.put("msg","账户名或密码输入错误，登录失败!");
                    }else if(e instanceof DisabledException){
                        map.put("msg","账户被禁用，登录失败!");
                    }else if(e instanceof AccountExpiredException){
                        map.put("msg","账户已过期，登录失败!");
                    }else if(e instanceof CredentialsExpiredException){
                        map.put("msg","密码已过期，登录失败!");
                    }else{
                        map.put("msg","登录失败!");
                    }
                    ObjectMapper mapper = new ObjectMapper();
                    out.write(mapper.writeValueAsString(map));
                    out.flush();
                    out.close();
                }
            })
            .permitAll() // 允许访问登录表单、登录接口
            .and().csrf().disable(); // 关闭csrf
    }
}
```

```java
// 配置 URL 访问权限
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests() // 开启 HttpSecurity 配置
            .antMatchers("/db/**").hasRole("DBA") // db/** 模式URL需DBA角色
            .antMatchers("/admin/**").hasRole("ADMIN") // admin/** 模式URL需ADMIN角色
            .antMatchers("/user/**").hasRole("USER") // user/** 模式URL需USER角色
            .anyRequest().authenticated() // 用户访问其它URL都必须认证后访问（登录后访问）
            .and()
            .formLogin().loginPage("/login.html")
            .loginProcessingUrl("/login").permitAll() // 开启表单登录并配置登录接口
            .and().logout() // 开启注销登录的配置
            .logoutUrl("/logout") // 配置注销登录请求URL为"/logout"（默认也就是 /logout）
            .clearAuthentication(true) // 清除身份认证信息
            .invalidateHttpSession(true) // 使 session 失效
            // 配置一个 LogoutHandler，开发者可以在这里完成一些数据清除工做
            .addLogoutHandler(new LogoutHandler() {
                @Override
                public void logout(HttpServletRequest req,
                                   HttpServletResponse resp,
                                   Authentication auth) {
                    System.out.println("注销登录，开始清除Cookie。");
                }
            })
            // 配置一个 LogoutSuccessHandler，开发者可以在这里处理注销成功后的业务逻辑
            .logoutSuccessHandler(new LogoutSuccessHandler() {
                @Override
                public void onLogoutSuccess(HttpServletRequest req,
                                            HttpServletResponse resp,
                                            Authentication auth)
                        throws IOException, ServletException {
                    // 我们可以跳转到登录页面
                    // resp.sendRedirect("/login");
 
                    // 也可以返回一段JSON提示
                    resp.setContentType("application/json;charset=utf-8");
                    PrintWriter out = resp.getWriter();
                    resp.setStatus(200);
                    Map<String, Object> map = new HashMap<>();
                    map.put("status", 200);
                    map.put("msg", "注销成功！");
                    ObjectMapper om = new ObjectMapper();
                    out.write(om.writeValueAsString(map));
                    out.flush();
                    out.close();
                }
            })
            .and().csrf().disable(); // 关闭csrf
    }
```

**开启SpringSecurity注解：@EnableGlobalMethodSecurity，该注解有两个参数：prePostEnabled=true/false，securedEnabled=true/false
prePostEnabled会解锁@PreAuthorize和@PostAuthorize两个注解，两个注解决定方法执行前或后进行验证
securedEnabled会解锁@Secured注解**
```java
@Service
public class MethodService {
 
    // 访问该方法需要 ADMIN 角色。注意：这里需要在角色前加一个前缀"ROLE_"
    @Secured("ROLE_ADMIN")
    public String admin() {
        return "hello admin";
    }
 
    // 访问该方法既要 ADMIN 角色，又要 DBA 角色
    @PreAuthorize("hasRole('ADMIN') and hasRole('DBA')")
    public String dba() {
        return "hello dba";
    }
 
    // 访问该方法只需要 ADMIN、DBA、USER 中任意一个角色即可
    @PreAuthorize("hasAnyRole('ADMIN','DBA','USER')")
    public String user() {
        return "hello user";
    }
}
```

获取用户信息：
```java
/**
     * 获取用户明细
     * @param principal
     * @return
     */
    @RequestMapping(value = "getUserInfo", method = RequestMethod.GET)
    public Principal getUserDetails(Principal principal) {
        logger.info("用户名:{}",principal.getName());
        return principal;
    }
    /**
     * 获取用户明细
     * @param authentication
     * @return
     */
    @RequestMapping(value = "getUserInfo2", method = RequestMethod.GET)
    public Authentication getUserInfo2(Authentication authentication) {
        logger.info("用户名:{}", authentication);
        return authentication;
    }

    /**
     * 只获取用户信息
     * @param userDetails
     * @return
     */
    @RequestMapping(value = "getUser", method = RequestMethod.GET)
    public UserDetails getUser(@AuthenticationPrincipal UserDetails userDetails) {
        logger.info("用户名:{}",userDetails.getUsername());
        return userDetails;
    }
	
	@GetMapping("/hello")
    public String hello() {
        return "当前登录用户：" + SecurityContextHolder.getContext().getAuthentication().getName();
    }
```

#### SpringSecurity+JWT
```java
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {
	@Autowired
	@Qualifier("userDetailsServiceImpl")
	private UserDetailsService userDetailsService;
	
	@Autowired
	private DataSource dataSource;
	
	@Bean
	public BCryptPasswordEncoder bCryptPasswordEncoder() {
		return new BCryptPasswordEncoder();
	}
	
	//RememberMe的数据库操作类
	@Bean
	public PersistentTokenRepository persistentTokenRepository() {
		JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl();
		jdbcTokenRepository.setDataSource(dataSource);
		return jdbcTokenRepository;
	}
	
	@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception {
		auth.userDetailsService(userDetailsService).passwordEncoder(bCryptPasswordEncoder());
	}
	
	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http.cors().and().csrf().disable()
		                .authorizeRequests()
		                .antMatchers(HttpMethod.DELETE, "/tasks/**").hasRole("ADMIN")
		                // 测试用资源，需要验证了的用户才能访问
		.antMatchers("/tasks/**").authenticated()
		                // 其他都放行了
		.anyRequest().permitAll()
		                .and()
		                //比较重要的两个过滤器
		                .addFilter(new JWTAuthenticationFilter(authenticationManager()))
		                .addFilter(new JWTAuthorizationFilter(authenticationManager()))
		                // 不需要session
		.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
		                .and()
		                .exceptionHandling().authenticationEntryPoint(new JWTAuthenticationEntryPoint())
		                .accessDeniedHandler(new JWTAccessDeniedHandler())//添加无权限时的处理
		                .and()
		                .rememberMe().tokenRepository(persistentTokenRepository())
		                .tokenValiditySeconds(60)
		                .userDetailsService(userDetailsService);//添加自动登录rememberMe的功能
	}
	@Bean
	CorsConfigurationSource corsConfigurationSource() {
		final UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
		source.registerCorsConfiguration("/**", new CorsConfiguration().applyPermitDefaultValues());
		return source;
	}
}
```

```java
@Service
public class UserDetailsServiceImpl implements UserDetailsService {
	
	@Autowired
	private UserRepository userRepository;
	
	@Override
	public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {
		User user = userRepository.findByUsername(s);
		return new JwtUser(user);
	}
}
```

```java
//登录时校验过滤器
public class JWTAuthenticationFilter extends UsernamePasswordAuthenticationFilter {

	private ThreadLocal<Integer> rememberMe = new ThreadLocal<>();
	private AuthenticationManager authenticationManager;
	
	public JWTAuthenticationFilter(AuthenticationManager authenticationManager) {
		this.authenticationManager = authenticationManager;
		super.setFilterProcessesUrl("/auth/login");
	}
	@Override
	public Authentication attemptAuthentication(HttpServletRequest request,
	    HttpServletResponse response) throws AuthenticationException {
		// 从输入流中获取到登录的信息
		try {
			LoginUser loginUser = new ObjectMapper().readValue(request.getInputStream(), LoginUser.class);
			rememberMe.set(loginUser.getRememberMe() == null ? 0 : loginUser.getRememberMe());
			return authenticationManager.authenticate(
			    new UsernamePasswordAuthenticationToken(loginUser.getUsername(), loginUser.getPassword(), new ArrayList<>()));
		}
		catch (IOException e) {
			e.printStackTrace();
			return null;
		}
	}
	// 成功验证后调用的方法
	// 如果验证成功，就生成token并返回
	@Override
	protected void successfulAuthentication(HttpServletRequest request,
						HttpServletResponse response,
						FilterChain chain,
						Authentication authResult) throws IOException, ServletException {
		JwtUser jwtUser = (JwtUser) authResult.getPrincipal();
		System.out.println("jwtUser:" + jwtUser.toString());
		Boolean isRemember = rememberMe.get() == 1;
		String role = "";
		Collection<? extends GrantedAuthority> authorities = jwtUser.getAuthorities();
		for (GrantedAuthority authority : authorities){
			role = authority.getAuthority();
		}
		String token = JwtTokenUtils.createToken(jwtUser.getUsername(), role, isRemember);
		//        String token = JwtTokenUtils.createToken(jwtUser.getUsername(), false);
		// 返回创建成功的token
		// 但是这里创建的token只是单纯的token
		// 按照jwt的规定，最后请求的时候应该是 `Bearer token`
		response.setHeader("token", JwtTokenUtils.TOKEN_PREFIX + token);
	}
	
	@Override
	protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException {
		response.getWriter().write("authentication failed, reason: " + failed.getMessage());
	}
}
```

```java
//验证认证时过滤器
public class JWTAuthorizationFilter extends BasicAuthenticationFilter {
	public JWTAuthorizationFilter(AuthenticationManager authenticationManager) {
		super(authenticationManager);
	}
	@Override
	protected void doFilterInternal(HttpServletRequest request,
	                    HttpServletResponse response,
	                    FilterChain chain) throws IOException, ServletException {
		String tokenHeader = request.getHeader(JwtTokenUtils.TOKEN_HEADER);
		// 如果请求头中没有Authorization信息则直接放行了
		if (tokenHeader == null || !tokenHeader.startsWith(JwtTokenUtils.TOKEN_PREFIX)) {
			chain.doFilter(request, response);
			return;
		}
		// 如果请求头中有token，则进行解析，并且设置认证信息
		try {
		SecurityContextHolder.getContext().setAuthentication(getAuthentication(tokenHeader));
		}
		catch (TokenIsExpiredException e) {
			//返回json形式的错误信息
			response.setCharacterEncoding("UTF-8");
			response.setContentType("application/json; charset=utf-8");
			response.setStatus(HttpServletResponse.SC_FORBIDDEN);
			String reason = "统一处理，原因：" + e.getMessage();
			response.getWriter().write(new ObjectMapper().writeValueAsString(reason));
			response.getWriter().flush();
			return;
		}
		super.doFilterInternal(request, response, chain);
	}
	// 这里从token中获取用户信息并新建一个token
	private UsernamePasswordAuthenticationToken getAuthentication(String tokenHeader) throws TokenIsExpiredException {
		String token = tokenHeader.replace(JwtTokenUtils.TOKEN_PREFIX, "");
		Boolean expiration = JwtTokenUtils.isExpiration(token);
		if (expiration) {
			throw new TokenIsExpiredException("token超时了");
		} else {
			String username = JwtTokenUtils.getUsername(token);
			String role = JwtTokenUtils.getUserRole(token);
			if (username != null) {
				return new UsernamePasswordAuthenticationToken(username, null,
				    Collections.singleton(new SimpleGrantedAuthority(role)));
			}
		}
		return null;
	}
}
```

## 6. Oauth
<img src="D:\Project\IT notes\技术要点\img\Oauth2中角色关系.png" style="width:700px;height:300px;" />
Oauth2设计标准中的角色：
- **资源所有者（Resource Owner）**：通常是用户，如昵称、头像这些资源的拥有者(用户只是将这些资源放到服务提供商的资源服务器中)
- **第三方应用**：或者称为第三方客户端(Clinet),希望使用资源服务器提供的资源
- **认证服务器(Authorization Server)**：专门用于对资源所有者的身份进行认证，对要访问的资源进行授权、产生令牌的服务器。访问资源，需要通过认证服务器由资源所有者授权才可以访问
- **资源服务器(Resource Server)**：存储用户的资源，验证令牌有效性。比如：微信资源服务器存储了微信用户信息，淘宝资源服务器存储了淘宝的用户信息
- **服务提供商(Service Provider)**：认证服务和资源服务归属于一个机构，该机构就是服务提供商

<img src="D:\Project\IT notes\技术要点\img\Oauth2认证流程.png" style="width:600px;height:600px;" />
Oauth2认证流程：
1. 第三方应用，向认证服务器请求授权
2. 用户告知认证服务器同意授权（通常是通过用户扫码或输入“服务提供商”的用户名密码的方式）
3. 认证服务器向第三方应用告知授权码（code）
4. 第三方应用使用授权码（code）申请Access Token
5. 认证服务器验证授权码，颁发Access Token

Oauth2的四种授权方式：
1. **授权码模式**
<img src="D:\Project\IT notes\技术要点\img\Oauth2授权码模式.png" style="width:600px;height:600px;" />
请求授权码：`/oauth/authorize?client_id=&response_type=code&scope=&redirect_uri=`
- client_id：客户端ID，由认证中心分配
- response_type：固定为code，表示返回授权码
- scope：要求的客户端的授权权限范围
- redirect_uri：认证中心同意或拒绝授权而跳转的地址，如同意会跳转时在uri后携带授权码code=xxx

返回授权码：`http://xxxx?code=NMoj5y`

请求令牌：`/oauth/token?client_id=&client_secret=&grant_type=authorization_code&code=NMoj5y&redirect_uri=`
- grant_type：授权类型，为固定值
- code：授权码

返回令牌：
- access_token：令牌
- refresh_token：刷新令牌

2. **简化模式**：与授权码模式不同在于，简化模式在用户授权后不发送授权码，而是把授权令牌发给客户端
<img src="D:\Project\IT notes\技术要点\img\Oauth2简化模式.png" style="width:600px;height:500px;" />
请求令牌：/oauth/authorize?response_type=token&client_id=&redirect_uri=&scope=
- redirect_uri：uri后直接携带令牌，而非授权码了

3. **密码模式**：用户向客户端直接提供认证服务器需要的用户名与密码；客户端将用户名密码发送给认证服务器；认证服务器确认用户名密码后直接向客户端提供访问令牌

请求令牌：/oauth/token?grant_type=password&username=&password=&client_id=&client_secret=
- grant_type：授权类型
- username：用户名
- password：密码
- client_id：客户端ID
- client_secret：客户端密钥

返回令牌：
- access_token
- token_type
- expires_in
- refresh_token
- scope
- uid

4. **客户端模式**：客户端直接向认证服务器申请令牌；认证服务器确认后，返回访问令牌
<img src="D:\Project\IT notes\技术要点\img\Oauth2客户端模式.png" style="width:600px;height:400px;" />
请求令牌：/oauth/token?grant_type=client_credentials&client_id=&client_secret=
返回令牌：
- access_token
- token_type
- expires_in
- scope

#### Oauth2+SpringBoot+SpringSecurity整合
```xml
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-security</artifactId>
</dependency>

<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-oauth2</artifactId>
</dependency>
```
