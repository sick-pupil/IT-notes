## 1. Optional判空
```java
Optional.empty() //返回一个空的Optional

optional.isEmpty() //判断Optional是否为空，为空则返回true

Optional.of(obj) //返回一个非空的Optional，如果obj为空，则报错NullPointException

Optional.ofNullable(obj) //返回Optional，不管obj是否为空

optional.get() //返回Optional之前的obj值，如果不存在则报错NoSuchElementException

optional.isPreSent() //optional存在值则返回true，否则为null返回false

optional.ifPresent(arg -> {}) //optional存在值则调用其中的方法参数

optional.orElse(obj) //optional存在值则返回，否则返回orElse中的obj

optional.orElseGet(arg -> {}) //optional存在值则返回，否则调用orElseGet中的方法参数

optional.orElseThrow(arg -> {}) //optional存在值则返回，否则调用orElseThrow中的方法参数抛出异常

optional.map(arg -> {}) //根据方法参数中的返回值，返回一个对应的optional，即使用optional封装一遍属性

optional.flatMap(arg -> {}) //根据方法参数中的返回值，返回一个对应的optional，和map不同的是flatMap返回的对象如果已经是optional类型的，则不会再用optional封装一遍

optional.filter(arg -> {}) //方法参数返回true or false，如果返回true则返回一个带值的optional，否则返回一个空的optional
```

## 2. Stream集合操作
### 1. 创建流
```java
//collection.stream()和collection.parallelStream()，集合实例调用实例方法获取stream
List<String> list = new ArrayList<>();
Stream<String> stream = list.stream(); //获取顺序流
Stream<String> parallelStream = list.parallelStream(); //获取并行流

//Arrays.stream()，数组调用Arrays.stream()静态方法获取stream
Integer[] nums = new Integer[10];
Stream<Integer> stream = Arrays.stream(nums);

//调用Stream中的静态方法
//Stream.of()
Stream<Integer> ofStream = Stream.of(1,2,3,4,5,6);
Stream<String> ofStream = Stream.of("a", "b", "c", "d", "e", "f");
Stream<Bubble> ofStream = Stream.of(new Bubble(1), new Bubble(2), new Bubble(3), new Bubble(4), new Bubble(5), new Bubble(6));

//Stream.iterate()，iterate中第一个参数可以理解为seed种子，seed被作为参数代入iterate方法中的第二个参数lambda中，可以看出是无限流，最后需要limit作限制
Stream<Integer> iterateStream = Stream.iterate(0, (n) -> n + 2).limit(10);

//Stream.generate()，可以理解为和Stream.iterate差不多，也是无限流，只是参数形式不太一样
Stream<Double> generateStream = Stream.generate(Math::random).limit(2);

//bufferedReader.lines()，将读取的所有行内容转为流
BufferedReader reader = new BufferedReader(new FileReader("..."));
Stream<String> linesStream = reader.lines();

//pattern.splitAsStream()将字符串分隔成流
Pattern pattern = Pattern.compile(";");
Stream<String> splitStream = pattern.splitAsStream("a;b;c;d");
```

### 2. 流操作
```java
Stream<Integer> stream = Stream.of(1,2,3,4,5,6,7,8,9,10);

//filter()，按照filter中的lambda参数过滤出符合条件的stream元素集合
stream.filter(num -> num >= 5);

//limit(n)，获取n个元素的stream元素集合
stream.limit(2);

//skip(n)，跳过n个元素，配合limit(n)能实现分页
stream.skip(10);

//distinct()，根据流中元素的hashCode()和equals()去除重复元素
stream.distinct()

//map()，接受一个lambda方法，该方法被应用到每个元素上，可以修改原本stream中的每个元素
stream.map(i -> i + 2);

//flatMap()，接受一个lambda方法，该方法被应用到每个元素上，并且必须返回stream，flatMap会把lambda得到的多个stream合并成一个大stream
stream.flatMap(it -> it.getList().stream());

//sorted()，自然排序，流中元素需实现Comparable接口
stream.sorted()
//sorted(Comparator com)，流中元素按照Comparator排序器排序
stream.sorted((o1, o2) -> {return o1.getField() - o2.getField()})

//全部元素符合条件才返回true
allMatch
//全部元素都不符合条件才返回true
noneMatch
//只要有一个元素符合条件才返回true
anyMatch
//返回流中第一个元素
findFirst
//返回流中任意元素
findAny
//流中元素总个数
count
//流中元素最大值
max
//流中元素最小值
min
```

### 3. 流生成
```java
stream.collect()
//stream流中的元素进行汇总，转成集合
Collectors.toList()
Collectors.toSet()
Collectors.toCollection()
Collectors.toMap()
Collectors.collectingAndThen()
Collectors.joining()
Collectors.counting()
Collectors.summarizingDouble() Collectors.summarizingLong() Collectors.summarizingInt()
Collectors.averagingDouble() Collectors.averagingLong() Collectors.averagingInt()
Collectors.summingDouble() Collectors.summingLong() Collectors.summingint()
Collectors.maxBy() Collectors.minBy()
Collectors.groupingBy()
Collectors.partitioningBy()
```

## 3. Valid
`Validation`是用于检查程序代码中参数的有效性的框架，作为`Spring`中的一个参数校验工具，集成在`Spring-Context`中
- `@AssertFalse`：适用于`Boolean`，验证注解元素值为`false`
- `@AssertTrue`：适用于`Boolean`，验证注解元素值为`true`
- `@NotNull`：适用于任意类型，验证注解的元素值不是`null`
- `@Null`：适用于任意类型，验证注解的元素值是`null`
- `@Min(value=值)`：适用于`BigDecimal`、`BigInteger`、`byte`、`short`、`int`、`long`、`任意Number或存储数字的CharSequence`，验证注解的元素值大于等于`@Min`指定的`value`值
- `@Max(value=值)`：适用于`BigDecimal`、`BigInteger`、`byte`、`short`、`int`、`long`、`任意Number或存储数字的CharSequence`，验证注解的元素值小于等于`@Max`指定的`value`值
- `@DecimalMin(value=值)`：与`@Min`基本一致，但`value`可以填写`decimal`
- `@DecimalMax(value=值)`：与`@Max`基本一致，但`value`可以填写`decimal`
- `@Digits(integer=整数位数, fraction=小数位数)`：适用类型与`@Min`一致，但验证元素值的整数位数与小数位数
- `@Size(min=下限, max=上限)`：适用于字符串、`Collection`、`Map`、数组，验证字符串或者集合的大小上下限
- `@Past`：适用于`java.util.Date java.util.Calendar java.Time`类库的日期类型，验证注解的元素值（日期类型）比当前时间早
- `@Future`：适用于`java.util.Date java.util.Calendar java.Time`类库的日期类型，验证注解的元素值（日期类型）比当前时间晚
- `@NotBlank`：适用于`CharSequence`子类型，验证注解的元素值不为空（不为`null`、去除首位空格后长度为0），不同于`@NotEmpty`，`@NotBlank`只应用于字符串且在比较时会去除字符串的首位空格
- `@Length(min=下限, max=上限)`：适用于`CharSequence`子类型，验证注解的元素值长度在`min`和`max`区间内
- `@NotEmpty`：适用于`CharSequence`子类型、`Collection`、`Map`、数组，验证注解的元素值不为`null`且不为空（字符串长度不为0、集合大小不为0）
- `@Range(min=最小值, max=最大值)`：适用于`BigDecimal, BigInteger, CharSequence, byte, short, int, long`等原子类型和包装类型，验证注解的元素值在最小值和最大值之间
- `@Email(regexp=正则表达式,flag=标志的模式)`
- `@Pattern(regexp=正则表达式,flag=标志的模式)`
- `@Valid`：指定递归验证关联的对象；如用户对象中有个地址对象属性，如果想在验证用户对象时一起验证地址对象的话，在地址对象上加`@Valid`注解即可级联验证

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```

```java
/**
 * 用户类
 */
@Setter
@Getter
@NoArgsConstructor
public class User implements Serializable {

   /**
    * 主键id
    */
   private Integer id;

   /**
    * 用户名
    */
   @NotEmpty(message = "用户名不能为空！")
   private String username;

   /**
    * 密码
    */
   @Size(min = 8, message = "密码长度不能小于8！")
   @NotEmpty(message = "密码不能为空！")
   private String password;

   /**
    * 邮箱
    */
   @Email(message = "邮箱格式错误！")
   private String email;

   /**
    * 年龄
    */
   @Min(value = 18, message = "年龄不能小于18！")
   @Max(value = 150, message = "年龄不能小于150！")
   private int age;

}

@PostMapping("/add")
public String add(@RequestBody @Valid User user, BindingResult errors) {
   if (errors.hasErrors()) {
      return errors.getFieldError().getDefaultMessage();
   }
   userService.add(user);
   return "添加成功！";
}
```

`Controller`方法参数中多了一个`BindingResult`类型的参数，该对象存放`validation`校验的错误信息，一般通过`hasErrors`方法判断是否有错误，通过`errors.getFieldError().getDefaultMessage()`获取错误信息

同为一个需要校验的类或者对象，可能在一个业务场景需要做A类型的校验，而在另一个业务场景需要做B类型的校验（`User`类，在`userAdd`接口需要`password`不为空，而在`userUpdate`接口则不需要填写`password`）

```java
package com.example.validationtest.param;

/**
 * 校验规则类
 */
public class ValidationRules {

   /**
    * 注册（添加）用户规则
    */
   public interface UserAdd {

   }

   /**
    * 更新（修改）用户规则
    */
   public interface UserUpdate {

   }

}


package com.example.validationtest.dataobject;

import com.example.validationtest.param.ValidationRules;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import javax.validation.constraints.*;
import java.io.Serializable;

/**
 * 用户类
 */
@Setter
@Getter
@NoArgsConstructor
public class User implements Serializable {

   /**
    * 主键id，将其设定分组为ValidationRules.UserUpdate，表示用户信息修改时校验该规则
    */
   @NotNull(groups = ValidationRules.UserUpdate.class, message = "用户id不能为空！")
   private Integer id;

   /**
    * 用户名，将其设定分组为ValidationRules.UserAdd，表示添加用户时校验该规则
    */
   @NotEmpty(groups = ValidationRules.UserAdd.class, message = "用户名不能为空！")
   private String username;

   /**
    * 密码，将长度校验规则同时加入到ValidationRules.UserAdd和ValidationRules.UserUpdate组，表示添加用户和用户信息修改时都要校验这个规则，空值校验只有添加时校验
    */
   @Size(groups = {ValidationRules.UserAdd.class, ValidationRules.UserUpdate.class}, 
	   min = 8, message = "密码长度不能小于8！")
   @NotEmpty(groups = ValidationRules.UserAdd.class, message = "密码不能为空！")
   private String password;

   // 下面都是一回事

   /**
    * 邮箱
    */
   @Email(groups = {ValidationRules.UserAdd.class, ValidationRules.UserUpdate.class}, 
	   message = "邮箱格式错误！")
   private String email;

   /**
    * 年龄
    */
   @Min(groups = {ValidationRules.UserAdd.class, ValidationRules.UserUpdate.class}, 
	   value = 18, message = "年龄不能小于18！")
   @Max(groups = {ValidationRules.UserAdd.class, ValidationRules.UserUpdate.class}, 
	   value = 150, message = "年龄不能小于150！")
   private int age;

}


package com.example.validationtest.api;

import com.example.validationtest.dataobject.User;
import com.example.validationtest.param.ValidationRules;
import org.springframework.validation.BindingResult;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * 测试校验（这里不做实际的用户添加删除工作，只是测试validation校验）
 */
@RestController
@RequestMapping("/api/user")
public class UserAPI {

   /**
    * 模拟添加用户，这里设置校验规则为ValidationRules.UserAdd
    */
   @PostMapping("/add")
   public String add(@RequestBody @Validated(ValidationRules.UserAdd.class) User user, 
	   BindingResult errors) {
      if (errors.hasErrors()) {
         return errors.getFieldError().getDefaultMessage();
      }
      return "添加成功！";
   }

   /**
    * 模拟修改用户，这里设置校验规则为ValidationRules.UserUpdate
    */
   @PostMapping("/update")
   public String update(@RequestBody @Validated(ValidationRules.UserUpdate.class) User user, 
	   BindingResult errors) {
      if (errors.hasErrors()) {
         return errors.getFieldError().getDefaultMessage();
      }
      return "修改成功！";
   }
}
```

## 4. Hutool
### 1. 日期时间
#### 1. DateUtil
```java
//Date、Long、Calendar类型互相转换
//当前时间
Date date = DateUtil.date();
//当前时间
Date date2 = DateUtil.date(Calendar.getInstance());
//当前时间
Date date3 = DateUtil.date(System.currentTimeMillis());
//当前时间字符串，格式：yyyy-MM-dd HH:mm:ss
String now = DateUtil.now();
//当前日期字符串，格式：yyyy-MM-dd
String today= DateUtil.today();


//格式化
String dateStr = "2017-03-01";
Date date = DateUtil.parse(dateStr);
//结果 2017/03/01
String format = DateUtil.format(date, "yyyy/MM/dd");
//常用格式的格式化，结果：2017-03-01
String formatDate = DateUtil.formatDate(date);
//结果：2017-03-01 00:00:00
String formatDateTime = DateUtil.formatDateTime(date);
//结果：00:00:00
String formatTime = DateUtil.formatTime(date);


//日期时间部分获取
Date date = DateUtil.date();
//获得年的部分
DateUtil.year(date);
//获得月份，从0开始计数
DateUtil.month(date);
//获得月份枚举
DateUtil.monthEnum(date);


//开始结束日期时间
String dateStr = "2017-03-01 22:33:23";
Date date = DateUtil.parse(dateStr);
//一天的开始，结果：2017-03-01 00:00:00
Date beginOfDay = DateUtil.beginOfDay(date);
//一天的结束，结果：2017-03-01 23:59:59
Date endOfDay = DateUtil.endOfDay(date);


//时间加减计算、偏移
String dateStr = "2017-03-01 22:33:23";
Date date = DateUtil.parse(dateStr);
//结果：2017-03-03 22:33:23
Date newDate = DateUtil.offset(date, DateField.DAY_OF_MONTH, 2);
//常用偏移，结果：2017-03-04 22:33:23
DateTime newDate2 = DateUtil.offsetDay(date, 3);
//常用偏移，结果：2017-03-01 19:33:23
DateTime newDate3 = DateUtil.offsetHour(date, -3);
//昨天
DateUtil.yesterday()
//明天
DateUtil.tomorrow()
//上周
DateUtil.lastWeek()
//下周
DateUtil.nextWeek()
//上个月
DateUtil.lastMonth()
//下个月
DateUtil.nextMonth()


//日期时间差
String dateStr1 = "2017-03-01 22:33:23";
Date date1 = DateUtil.parse(dateStr1);
String dateStr2 = "2017-04-01 23:33:23";
Date date2 = DateUtil.parse(dateStr2);
//相差一个月，31天
long betweenDay = DateUtil.between(date1, date2, DateUnit.DAY);
//Level.MINUTE表示精确到分
String formatBetween = DateUtil.formatBetween(between, Level.MINUTE);
//输出：31天1小时
Console.log(formatBetween);
```

#### 2. DateTime
```java
Date date = new Date();
//new方式创建
DateTime time = new DateTime(date);
Console.log(time);
//of方式创建
DateTime now = DateTime.now();
DateTime dt = DateTime.of(date);


//日期时间部分获取
DateTime dateTime = new DateTime("2017-01-05 12:34:23", DatePattern.NORM_DATETIME_FORMAT);
//年，结果：2017
int year = dateTime.year();
//季度（非季节），结果：Season.SPRING
Season season = dateTime.seasonEnum();
//月份，结果：Month.JANUARY
Month month = dateTime.monthEnum();
//日，结果：5
int day = dateTime.dayOfMonth();


//DateTime为可变对象，可设置为不可变对象
DateTime dateTime = new DateTime("2017-01-05 12:34:23", DatePattern.NORM_DATETIME_FORMAT);
//默认情况下DateTime为可变对象，此时offset == dateTime
DateTime offset = dateTime.offset(DateField.YEAR, 0);
//设置为不可变对象后变动将返回新对象，此时offset != dateTime
dateTime.setMutable(false);
offset = dateTime.offset(DateField.YEAR, 0);
```

### 2. 加密解密
```java
//hex 16进制加密解密
String str = "我是一个字符串";
String hex = HexUtil.encodeHexStr(str, CharsetUtil.CHARSET_UTF_8);
//hex是：
//e68891e698afe4b880e4b8aae5ad97e7aca6e4b8b2
String decodedStr = HexUtil.decodeHexStr(hex);
//解码后与str相同


//base62
String a = "伦家是一个非常长的字符串66";
// 17vKU8W4JMG8dQF8lk9VNnkdMOeWn4rJMva6F0XsLrrT53iKBnqo
String encode = Base62.encode(a);
// 还原为a
String decodeStr = Base62.decodeStr(encode);


//base64
String a = "伦家是一个非常长的字符串";
//5Lym5a625piv5LiA5Liq6Z2e5bi46ZW/55qE5a2X56ym5Liy
String encode = Base64.encode(a);
// 还原为a
String decodeStr = Base64.decodeStr(encode);


//base32
String a = "伦家是一个非常长的字符串";
String encode = Base32.encode(a);
Assert.assertEquals("4S6KNZNOW3TJRL7EXCAOJOFK5GOZ5ZNYXDUZLP7HTKCOLLMX46WKNZFYWI", encode);
String decodeStr = Base32.decodeStr(encode);
Assert.assertEquals(a, decodeStr);


//AES
String content = "test中文";
//随机生成密钥
byte[] key = SecureUtil.generateKey(SymmetricAlgorithm.AES.getValue()).getEncoded();
//构建
SymmetricCrypto aes = new SymmetricCrypto(SymmetricAlgorithm.AES, key);
//加密
byte[] encrypt = aes.encrypt(content);
//解密
byte[] decrypt = aes.decrypt(encrypt);
//加密为16进制表示
String encryptHex = aes.encryptHex(content);
//解密为字符串
String decryptStr = aes.decryptStr(encryptHex, CharsetUtil.CHARSET_UTF_8);


//DESede
String content = "test中文";
byte[] key = SecureUtil.generateKey(SymmetricAlgorithm.DESede.getValue()).getEncoded();
SymmetricCrypto des = new SymmetricCrypto(SymmetricAlgorithm.DESede, key);
//加密
byte[] encrypt = des.encrypt(content);
//解密
byte[] decrypt = des.decrypt(encrypt);
//加密为16进制字符串（Hex表示）
String encryptHex = des.encryptHex(content);
//解密为字符串
String decryptStr = des.decryptStr(encryptHex);


//RSA
RSA rsa = new RSA();
//获得私钥
rsa.getPrivateKey();
rsa.getPrivateKeyBase64();
//获得公钥
rsa.getPublicKey();
rsa.getPublicKeyBase64();
//公钥加密，私钥解密
byte[] encrypt = rsa.encrypt(StrUtil.bytes("我是一段测试aaaa", CharsetUtil.CHARSET_UTF_8), KeyType.PublicKey);
byte[] decrypt = rsa.decrypt(encrypt, KeyType.PrivateKey);
//私钥加密，公钥解密
byte[] encrypt2 = rsa.encrypt(StrUtil.bytes("我是一段测试aaaa", CharsetUtil.CHARSET_UTF_8), KeyType.PrivateKey);
byte[] decrypt2 = rsa.decrypt(encrypt2, KeyType.PublicKey);
```

### 3. HTTP
```java
//GET
// 最简单的HTTP请求，可以自动通过header等信息判断编码，不区分HTTP和HTTPS
String result1= HttpUtil.get("https://www.baidu.com");
// 当无法识别页面编码的时候，可以自定义请求页面的编码
String result2= HttpUtil.get("https://www.baidu.com", CharsetUtil.CHARSET_UTF_8);
//可以单独传入http参数，这样参数会自动做URL编码，拼接在URL中
HashMap<String, Object> paramMap = new HashMap<>();
paramMap.put("city", "北京");
String result3= HttpUtil.get("https://www.baidu.com", paramMap);


//POST
HashMap<String, Object> paramMap = new HashMap<>();
paramMap.put("city", "北京");
String result= HttpUtil.post("https://www.baidu.com", paramMap);


//文件上传
HashMap<String, Object> paramMap = new HashMap<>();
//文件上传只需将参数中的键指定（默认file），值设为文件对象即可，对于使用者来说，文件上传与普通表单提交并无区别
paramMap.put("file", FileUtil.file("D:\\face.jpg"));
String result= HttpUtil.post("https://www.baidu.com", paramMap);


//文件下载
String fileUrl = "http://mirrors.sohu.com/centos/8.4.2105/isos/x86_64/CentOS-8.4.2105-x86_64-dvd1.iso";
//将文件下载后保存在E盘，返回结果为下载文件大小
long size = HttpUtil.downloadFile(fileUrl, FileUtil.file("e:/"));
System.out.println("Download size: " + size);


String result2 = HttpRequest.post(url)
    .header(Header.USER_AGENT, "Hutool http")//头信息，多个头信息多次调用此方法即可
    .form(paramMap)//表单内容
    .timeout(20000)//超时，毫秒
    .execute().body();
Console.log(result2);

String json = ...;
String result2 = HttpRequest.post(url)
    .body(json)
    .execute().body();

HttpResponse res = HttpRequest.post(url)..execute();
Console.log(res.getStatus());

HttpResponse res = HttpRequest.post(url)..execute();
//预定义的头信息
Console.log(res.header(Header.CONTENT_ENCODING));
//自定义头信息
Console.log(res.header("Content-Disposition"));


```

### 4. 命令行
```java
String str = RuntimeUtil.execForStr("ipconfig");
List<String> strList = RuntimeUtil.execForStr("ipconfig");
```

### 5. ID
```java
//UUID
//生成的UUID是带-的字符串，类似于：a5c8a5e8-df2b-4706-bea4-08d0939410e3
String uuid = IdUtil.randomUUID();
//生成的是不带-的字符串，类似于：b17f24ff026d40949c85a24f4f375d42
String simpleUUID = IdUtil.simpleUUID();


//ObjectId
//生成类似：5b9e306a4df4f8c54a39fb0c
String id = ObjectId.next();
//方法2：从Hutool-4.1.14开始提供
String id2 = IdUtil.objectId();


//Snowflake
//参数1为终端ID
//参数2为数据中心ID
Snowflake snowflake = IdUtil.getSnowflake(1, 1);
long id = snowflake.nextId();
//简单使用
long id = IdUtil.getSnowflakeNextId();
String id = snowflake.getSnowflakeNextIdStr();
```

## 5. Apache-Commons
### 1. Lang
<img src="D:\Project\IT-notes\技术要点\img\apache-commons-lang.png" style="width:700px;height:350px;" />

```xml
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-lang3</artifactId>
    <version>3.12.0</version>
</dependency>
```

#### 1. 日期时间
##### 1. 字符串转日期
```java
final String strDate = "2021-07-04 11:11:11";
final String pattern = "yyyy-MM-dd HH:mm:ss";
Date date2 = DateUtils.parseDate(strDate, pattern);
```

##### 2. 日期转字符串
```java
final Date date = new Date();
final String pattern = "yyyy年MM月dd日";
String strDate = DateFormatUtils.format(date, pattern);
```

##### 3. 日期计算
```java
final Date date = new Date();
Date newDate1 = DateUtils.addDays(date, 5); // 加5天
Date newDate2 = DateUtils.addHours(date, -5); // 减5小时
Date newDate3 = DateUtils.truncate(date, Calendar.DATE); // 过滤时分秒
boolean isSameDay = DateUtils.isSameDay(newDate1, newDate2); // 判断是否是同一天
```

#### 2. 字符串
##### 1. 判空
```java
//判空
boolean isEmpty = StringUtils.isEmpty(str);
boolean isNotEmpty = StringUtils.isNotEmpty(str);
//去除空格后判空
boolean isBlank = StringUtils.isBlank(str);
boolean isNotBlank = StringUtils.isNotBlank(str);
//只要有一个为空则true
boolean isAnyEmpty = StringUtils.isAnyEmpty(str1, str2, str3);
//所有都为空则true
boolean isAllEmpty = StringUtils.isAllEmpty(str1, str2, str3);
```

##### 2. 去空格
```java
//去除两侧空格并返回新字符串
String newStr = StringUtils.trim();
//去除两侧空格后如果为null则返回空字符串
newStr = StringUtils.trimToEmpty(str);
//去除两侧空格后如果为空字符串则返回null
newStr = StringUtils.trimToNull(str);
//去除两侧指定的任意字符，如去除两侧的'a' 'b' 'c'字符
newStr = StringUtils.strip(str, "abc");
//去除左侧指定的任意字符
newStr = StringUtils.stripStart(str, "abc");
//去除右侧指定的任意字符
newStr = StringUtils.stripEnd(str, "abc");
```

##### 3. 分割
```java
//默认指定空格为分隔符
StringUtils.split(str);
//指定分隔符并分割字符串
StringUtils.split(str, ",");
```

##### 4. 取子字符串
```java
//获得"aa.bb.cc"字符串中最后一个'.'之前的字符串
StringUtils.substringBeforeLast("aa.bb.cc", "."); //aa.bb
//获得"aa.bb.cc"字符串中最后一个'.'之后的字符串
StringUtils.substringAfterLast("aa.bb.cc", "."); //cc
//获得"aa.bb.cc"字符串中第一个'.'之前的字符串
StringUtils.substringBefore("aa.bb.cc", "."); //aa
//获得"aa.bb.cc"字符串中第一个'.'之后的字符串
StringUtils.substringAfter("aa.bb.cc", "."); //cc
// 获取"ab.cc.txt"中.之间的字符串
StringUtils.substringBetween("ab.cc.txt", "."); //cc
StringUtils.substringBetween("a(bb)c", "(", ")"); //bb
```

##### 5. 其他
```java
// 首字母大写
StringUtils.capitalize("test"); // Test
// 字符串合并
StringUtils.join(new int[]{1,2,3}, ",");// 1,2,3
// 缩写
StringUtils.abbreviate("abcdefg", 6);// "abc..."
// 判断字符串是否是数字
StringUtils.isNumeric("abc123");// false
// 删除指定字符
StringUtils.remove("abbc", "b"); // ac

// 随机生成长度为5的字符串
RandomStringUtils.random(5);
// 随机生成长度为5的"只含大小写字母"字符串
RandomStringUtils.randomAlphabetic(5);
// 随机生成长度为5的"只含大小写字母和数字"字符串
RandomStringUtils.randomAlphanumeric(5);
// 随机生成长度为5的"只含数字"字符串
RandomStringUtils.randomNumeric(5);
```

#### 3. 反射
```java
//读写属性
String value2 = (String) FieldUtils.readDeclaredField(reflectDemo, "abc", true); //123
public class ReflectDemo {
    private static String sAbc = "111";
    private String abc = "123";
    public void fieldRelated() throws Exception {
        ReflectDemo reflectDemo = new ReflectDemo();
        // 反射获取对象属性的值
        String value2 = (String) FieldUtils.readField(reflectDemo, "abc", true);//123
        // 反射获取类静态属性的值
        String value3 = (String) FieldUtils.readStaticField(ReflectDemo.class, "sAbc", true);//111
        // 反射设置对象属性值
        FieldUtils.writeField(reflectDemo, "abc", "newValue", true);
        // 反射设置类静态属性的值
        FieldUtils.writeStaticField(ReflectDemo.class, "sAbc", "newStaticValue", true);
    }
}

//获取被注解注释的方法
// 原生写法
List<Method> annotatedMethods = new ArrayList<Method>();
for (Method method : ReflectDemo.class.getMethods()) {
    if (method.getAnnotation(Test.class) != null) {
        annotatedMethods.add(method);
    }
}
// commons写法
Method[] methods = MethodUtils.getMethodsWithAnnotation(ReflectDemo.class, Test.class);


//调用方法
private static void testStaticMethod(String param1) {}
private void testMethod(String param1) {}
public void invokeDemo() throws Exception {
    // 调用函数"testMethod"
    ReflectDemo reflectDemo = new ReflectDemo();
    // 原生写法
    Method testMethod = reflectDemo.getClass().getDeclaredMethod("testMethod");
    testMethod.setAccessible(true); // 设置访问级别，如果private函数不设置则调用会报错
    testMethod.invoke(reflectDemo, "testParam");
    // commons写法
    MethodUtils.invokeExactMethod(reflectDemo, "testMethod", "testParam");
    
    // ---------- 类似方法 ----------
    // 调用static方法
    MethodUtils.invokeExactStaticMethod(ReflectDemo.class, "testStaticMethod", "testParam");
    // 调用方法(含继承过来的方法)
    MethodUtils.invokeMethod(reflectDemo, "testMethod", "testParam");
    // 调用static方法(当前不存在则向父类寻找匹配的静态方法)
    MethodUtils.invokeStaticMethod(ReflectDemo.class, "testStaticMethod", "testParam");
}
```

#### 4. 系统
```java
// 判断操作系统类型
boolean isWin = SystemUtils.IS_OS_WINDOWS;
boolean isWin10 = SystemUtils.IS_OS_WINDOWS_10;
boolean isWin2012 = SystemUtils.IS_OS_WINDOWS_2012;
boolean isMac = SystemUtils.IS_OS_MAC;
boolean isLinux = SystemUtils.IS_OS_LINUX;
boolean isUnix = SystemUtils.IS_OS_UNIX;
boolean isSolaris = SystemUtils.IS_OS_SOLARIS;
// ... ...

// 判断java版本
boolean isJava6 = SystemUtils.IS_JAVA_1_6;
boolean isJava8 = SystemUtils.IS_JAVA_1_8;
boolean isJava11 = SystemUtils.IS_JAVA_11;
boolean isJava14 = SystemUtils.IS_JAVA_14;
// ... ...

// 获取java相关目录
File javaHome = SystemUtils.getJavaHome();
File userHome = SystemUtils.getUserHome();// 操作系统用户目录
File userDir = SystemUtils.getUserDir();// 项目所在路径
File tmpDir = SystemUtils.getJavaIoTmpDir();
```

### 2. IO
<img src="D:\Project\IT-notes\技术要点\img\apache-commons-io.png" style="width:700px;height:250px;" />

```xml
<dependency>
    <groupId>commons-io</groupId>
    <artifactId>commons-io</artifactId>
    <version>2.11.0</version>
</dependency>
```

#### 1. 输入输出流
```java
InputStream inputStream = new FileInputStream("test.txt");
OutputStream outputStream = new FileOutputStream("test.txt");
// 原生写法
if (inputStream != null) {
    try {
        inputStream.close();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
if (outputStream != null) {
    try {
        outputStream.close();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
// commons写法(可以传任意数量的流)
IOUtils.closeQuietly(inputStream, outputStream);


// ==== 输入流转换为byte数组 ====
// 原生写法
InputStream is = new FileInputStream("foo.txt");
byte[] buf = new byte[1024];
int len;
ByteArrayOutputStream out = new ByteArrayOutputStream();
while ((len = is.read(buf)) != -1) {
    out.write(buf, 0, len);
}
byte[] result = out.toByteArray();
// commons写法，输入流读出字节
byte[] result2 = IOUtils.toByteArray(is);
// commons写法，输入流读出字符串
String result2 = IOUtils.toString(is, "UTF-8");
// 将reader转换为字符串
String toString(Reader reader, String charset) throws IOException;
// 将url转换为字符串，也就是可以直接将网络上的内容下载为字符串
String toString(URL url, String charset) throws IOException;


// 按照行读取结果
InputStream is = new FileInputStream("test.txt");
List<String> lines = IOUtils.readLines(is, "UTF-8");

// 将行集合写入输出流
OutputStream os = new FileOutputStream("newTest.txt");
IOUtils.writeLines(lines, System.lineSeparator(), os, "UTF-8");

// 拷贝输入流到输出流
InputStream inputStream = new FileInputStream("src.txt");
OutputStream outputStream = new FileOutputStream("dest.txt");
IOUtils.copy(inputStream, outputStream);

//自动关闭输入流
InputStream is = new FileInputStream("test.txt");
AutoCloseInputStream acis = new AutoCloseInputStream(is);
IOUtils.toByteArray(acis); // 将流全部读完

// 从后向前按行读取
try (ReversedLinesFileReader reader = new ReversedLinesFileReader(new File("test.txt"), Charset.forName("UTF-8"))) {
    String lastLine = reader.readLine(); // 读取最后一行
    List<String> line5 = reader.readLines(5); // 从后再读5行
}

//计数流
InputStream is = new FileInputStream("test.txt");
try (CountingInputStream cis = new CountingInputStream(is)) {
	String txt = IOUtils.toString(cis, "UTF-8"); // 文件内容
	long size = cis.getByteCount(); // 读取的字节数
} catch (IOException e) {
	// 异常处理
}


//可观察的输入流（典型的观察者模式），可实现边读取边处理
private class MyObservableInputStream extends ObservableInputStream {
    class MyObserver extends Observer {
        @Override
        public void data(final int input) throws IOException {
            // 做自定义处理
        }
        @Override
        public void data(final byte[] input, final int offset, final int length) throws IOException {
            // 做自定义处理
        }
    }
    public MyObservableInputStream(InputStream inputStream) {
        super(inputStream);
    }
}


//BOMInputStream: 同时读取文本文件的bom头

//BoundedInputStream：有界的流，控制只允许读取前x个字节

//BrokenInputStream: 一个错误流，永远抛出IOException

//CharSequenceInputStream: 支持StringBuilder,StringBuffer等读取

//LockableFileWriter: 带锁的Writer，同一个文件同时只允许一个流写入，多余的写入操作会跑出IOException

//StringBuilderWriter: StringBuilder的Writer
```

#### 2. 文件读写
**FileUtils、FilenameUtils、PathUtils**
```java
File readFile = new File("test.txt");
// 读取文件
String str = FileUtils.readFileToString(readFile, "UTF-8");
// 读取文件为字节数组
byte[] bytes = FileUtils.readFileToByteArray(readFile);
// 按行读取文件
List<String> lines =  FileUtils.readLines(readFile, "UTF-8");

File writeFile = new File("out.txt");
// 将字符串写入文件
FileUtils.writeStringToFile(writeFile, "测试文本", "UTF-8");
// 将字节数组写入文件
FileUtils.writeByteArrayToFile(writeFile, bytes);
// 将字符串列表一行一行写入文件
FileUtils.writeLines(writeFile, lines, "UTF-8");
```

#### 3. 文件移动复制
```java
File srcFile = new File("src.txt");
File destFile = new File("dest.txt");
File srcDir = new File("/srcDir");
File destDir = new File("/destDir");
// 移动/拷贝文件
FileUtils.moveFile(srcFile, destFile);
FileUtils.copyFile(srcFile, destFile);
// 移动/拷贝文件到目录
FileUtils.moveFileToDirectory(srcFile, destDir, true);
FileUtils.copyFileToDirectory(srcFile, destDir);
// 移动/拷贝目录
FileUtils.moveDirectory(srcDir, destDir);
FileUtils.copyDirectory(srcDir, destDir);
// 拷贝网络资源到文件
FileUtils.copyURLToFile(new URL("http://xx"), destFile);
// 拷贝流到文件
FileUtils.copyInputStreamToFile(new FileInputStream("test.txt"), destFile);
```

#### 4. 文件名
```java
// 获取名称，后缀等
String name = "/home/xxx/test.txt";
FilenameUtils.getName(name); // "test.txt"
FilenameUtils.getBaseName(name); // "test"
FilenameUtils.getExtension(name); // "txt"
FilenameUtils.getPath(name); // "/home/xxx/"
```

#### 5. Path
```java
// 获取当前路径
Path path = PathUtils.current();
// 删除path
PathUtils.delete(path);
// 路径或文件是否为空
PathUtils.isEmpty(path);
// 设置只读
PathUtils.setReadOnly(path, true);
// 复制
PathUtils.copyFileToDirectory(Paths.get("test.txt"), path);
PathUtils.copyDirectory(Paths.get("/srcPath"), Paths.get("/destPath"));
// 统计目录内文件数量
Counters.PathCounters counters = PathUtils.countDirectory(path);
counters.getByteCounter(); // 字节大小
counters.getDirectoryCounter(); // 目录个数
counters.getFileCounter(); // 文件个数
```

#### 6. 文件排序器
```java
List<File> files = Arrays.asList(new File[]{
        new File("/foo/def"),
        new File("/foo/test.txt"),
        new File("/foo/abc"),
        new File("/foo/hh.txt")});
// 排序目录在前
Collections.sort(files, DirectoryFileComparator.DIRECTORY_COMPARATOR); // ["/foo/def", "/foo/abc", "/foo/test.txt", "/foo/hh.txt"]
// 排序目录在后
Collections.sort(files, DirectoryFileComparator.DIRECTORY_REVERSE); // ["/foo/test.txt", "/foo/hh.txt", "/foo/def", "/foo/abc"]
// 组合排序，首先按目录在前排序，其次再按照名称排序
Comparator dirAndNameComp = new CompositeFileComparator(
            DirectoryFileComparator.DIRECTORY_COMPARATOR,
            NameFileComparator.NAME_COMPARATOR);
Collections.sort(files, dirAndNameComp); // ["/foo/abc", "/foo/def", "/foo/hh.txt", "/foo/test.txt"]
```

#### 7. 文件监听器
```java
public static void main(String[] args) throws Exception {
    // 监听目录下文件变化。可通过参数控制监听某些文件，默认监听目录所有文件
    FileAlterationObserver observer = new FileAlterationObserver("/foo");
    observer.addListener(new myListener());
    FileAlterationMonitor monitor = new FileAlterationMonitor();
    monitor.addObserver(observer);
    monitor.start(); // 启动监视器
    Thread.currentThread().join(); // 避免主线程退出造成监视器退出
}

private class myListener extends FileAlterationListenerAdaptor {
    @Override
    public void onFileCreate(File file) {
        System.out.println("fileCreated:" + file.getAbsolutePath());
    }
    @Override
    public void onFileChange(File file) {
        System.out.println("fileChanged:" + file.getAbsolutePath());
    }
    @Override
    public void onFileDelete(File file) {
        System.out.println("fileDeleted:" + file.getAbsolutePath());
    }
}
```

#### 8. 其他
```java
File file = new File("test.txt");
File dir = new File("/test");
// 删除文件
FileUtils.delete(file);
// 删除目录
FileUtils.deleteDirectory(dir);
// 文件大小，如果是目录则递归计算总大小
long s = FileUtils.sizeOf(file);
// 则递归计算目录总大小，参数不是目录会抛出异常
long sd = FileUtils.sizeOfDirectory(dir);
// 递归获取目录下的所有文件
Collection<File> files = FileUtils.listFiles(dir, null, true);
// 获取jvm中的io临时目录
FileUtils.getTempDirectory();
```

### 3. Codec
<img src="D:\Project\IT-notes\技术要点\img\apache-commons-codec.png" style="width:700px;height:200px;" />

```xml
<dependency>
    <groupId>commons-codec</groupId>
    <artifactId>commons-codec</artifactId>
    <version>1.15</version>
</dependency>
```

#### 1. Hex
```java
// byte数组转为16进制字符串
String hex = Hex.encodeHexString("123".getBytes());
System.out.println(hex);
// 16进制字符串解码
byte[] src = Hex.decodeHex(hex);
System.out.println(new String(src));
```

#### 2. Base64/Base32/Base16
```java
// base64编码
String base64 = Base64.encodeBase64String("测试".getBytes());
System.out.println(base64);
// base64解码
byte[] src = Base64.decodeBase64(base64);
System.out.println(new String(src));
// 字符串是否是base64
Base64.isBase64(base64);



// 以流方式提供Base64编码和解码
// 附："123"的base64编码为"MTIz"
// 对输入流做base64编码
InputStream is = new ByteArrayInputStream("123".getBytes());
Base64InputStream ebis = new Base64InputStream(is, true);
String enc = IOUtils.toString(ebis, "UTF-8"); // MTIz
// 对base64数据流做解码
is = new ByteArrayInputStream(enc.getBytes());
Base64InputStream dbis = new Base64InputStream(is, false);
String dec = IOUtils.toString(dbis, "UTF-8"); // 123

// 将数据做base64编码写入输出流
final String data = "123";
ByteArrayOutputStream baos = new ByteArrayOutputStream();
Base64OutputStream ebos = new Base64OutputStream(baos, true);
IOUtils.write(data, ebos, "UTF-8");
String enc2 = baos.toString(); // MTIz
// 将base64数据做解码写入输出流
baos = new ByteArrayOutputStream();
Base64OutputStream dbos = new Base64OutputStream(baos, false);
IOUtils.write(data, dbos, "UTF-8");
String dec2 = dbos.toString(); // 123
```

#### 3. URL
```java
URLCodec urlCodec = new URLCodec();
// url编码
String encUrl = urlCodec.encode("http://x.com?f=哈");
System.out.println(encUrl);
// url解码
String decUrl = urlCodec.decode(encUrl);
System.out.println(decUrl);
```

#### 4. MD/SHA/HMAC
```java
String md5 = DigestUtils.md5Hex("测试");

String sha1 = DigestUtils.sha1Hex("测试");
String sha256 = DigestUtils.sha256Hex("测试");
String sha384 = DigestUtils.sha384Hex("测试");
String sha512 = DigestUtils.sha512Hex("测试");
String sha3_256 = DigestUtils.sha3_256Hex("测试");
String sha3_384 = DigestUtils.sha3_384Hex("测试");
String sha3_512 = DigestUtils.sha3_512Hex("测试");

String key = "asdf3234asdf3234asdf3234asdf3234";
String valueToDigest = "测试数据"; // valueToDigest参数支持字节数据，流，文件等
// 做HMAC-MD5摘要
String hmacMd5 = new HmacUtils(HmacAlgorithms.HMAC_MD5, key).hmacHex(valueToDigest);
// 做HMAC-sha摘要
String hmacSha256 = new HmacUtils(HmacAlgorithms.HMAC_SHA_256, key).hmacHex(valueToDigest);
String hmacSha384 = new HmacUtils(HmacAlgorithms.HMAC_SHA_384, key).hmacHex(valueToDigest);
String hmacSha512 = new HmacUtils(HmacAlgorithms.HMAC_SHA_512, key).hmacHex(valueToDigest);
```

### 4. Compress
<img src="D:\Project\IT-notes\技术要点\img\apache-commons-compress.png" style="width:700px;height:200px;" />

```xml
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-compress</artifactId>
    <version>1.21</version>
</dependency>
```

#### 1. 压缩
- `.gz`：`GzipCompressorOutputStream、GzipCompressorInputStream`
- `.bz2`：`BZip2CompressorOutputStream、BZip2CompressorInputStream`
- `.xz`：`XZCompressorOutputStream、XZCompressorInputStream`
- `.lz4`：`FramedLZ4CompressorOutputStream、FramedLZ4CompressorInputStream`
- `.block_lz4`：`BlockLZ4CompressorOutputStream、BlockLZ4CompressorInputStream`
- `.pack`：`Pack200CompressorOutputStream、Pack200CompressorInputStream`
- `.deflate`：`DeflateCompressorOutputStream、DeflateCompressorInputStream`
- `.lzma`：`LZMACompressorOutputStream、LZMACompressorInputStream`
- `.sz`：`FramedSnappyCompressorOutputStream、FramedSnappyCompressorInputStream`
- `.z`：`ZCompressorInputStream`

```java
// gzip压缩
String file = "/test.js";
GzipParameters parameters = new GzipParameters();
parameters.setCompressionLevel(Deflater.BEST_COMPRESSION);
parameters.setOperatingSystem(3);
parameters.setFilename(FilenameUtils.getName(file));
parameters.setComment("Test file");
parameters.setModificationTime(System.currentTimeMillis());
FileOutputStream fos = new FileOutputStream(file + ".gz");
try (GzipCompressorOutputStream gzos = new GzipCompressorOutputStream(fos, parameters);
    InputStream is = new FileInputStream(file)) {
    IOUtils.copy(is, gzos);
}
// gzip解压
String gzFile = "/test.js.gz";
FileInputStream is = new FileInputStream(gzFile);
try (GzipCompressorInputStream gis = new GzipCompressorInputStream(is)) {
    GzipParameters p = gis.getMetaData();
    File targetFile = new File("/test.js");
    FileUtils.copyToFile(gis, targetFile);
    targetFile.setLastModified(p.getModificationTime());
}


// 压缩bz2
String srcFile = "/test.tar";
String targetFile = "/test.tar.bz2";
FileOutputStream os = new FileOutputStream(targetFile);
try (BZip2CompressorOutputStream bzos = new BZip2CompressorOutputStream(os);
    InputStream is = new FileInputStream(srcFile)) {
    IOUtils.copy(is, bzos);
}
// 解压bz2
String bzFile = "/test.tar.bz2";
FileInputStream is = new FileInputStream(bzFile);
try (BZip2CompressorInputStream bzis = new BZip2CompressorInputStream(is)) {
    File targetFile = new File("test.tar");
    FileUtils.copyToFile(bzis, targetFile);
}
```

#### 2. 归档
- `.tar`：`TarArchiveOutputStream、TarArchiveInputStream`
- `.zip`：`ZipArchiveOutputStream、ZipArchiveInputStream`
- `.jar`：`JarArchiveOutputStream、JarArchiveInputStream`
- `.dump`：`DumpArchiveOutputStream、DumpArchiveInputStream`
- `.cpio`：`CpioArchiveOutputStream、CpioArchiveInputStream`
- `.ar`：`ArArchiveOutputStream、ArArchiveInputStream`
- `.arj`：`ArjArchiveInputStream`
- `.7z`：`SevenZOutputFile、SevenZFile`

```java
// tar压缩
public void tar() throws IOException {
    File srcDir = new File("/test");
    String targetFile = "/test.tar";
    try (TarArchiveOutputStream tos = new TarArchiveOutputStream(
            new FileOutputStream(targetFile))) {
        tarRecursive(tos, srcDir, "");
    }
}
// 递归压缩目录下的文件和目录
private void tarRecursive(TarArchiveOutputStream tos, File srcFile, String basePath) 
	throws IOException {
    if (srcFile.isDirectory()) {
        File[] files = srcFile.listFiles();
        String nextBasePath = basePath + srcFile.getName() + "/";
        if (ArrayUtils.isEmpty(files)) {
            // 空目录
            TarArchiveEntry entry = new TarArchiveEntry(srcFile, nextBasePath);
            tos.putArchiveEntry(entry);
            tos.closeArchiveEntry();
        } else {
            for (File file : files) {
                tarRecursive(tos, file, nextBasePath);
            }
        }
    } else {
        TarArchiveEntry entry = new TarArchiveEntry(srcFile, basePath + srcFile.getName());
        tos.putArchiveEntry(entry);
        FileUtils.copyFile(srcFile, tos);
        tos.closeArchiveEntry();
    }
}
// tar解压
public void untar() throws IOException {
    InputStream is = new FileInputStream("/test.tar");
    String outPath = "/test";
    try (TarArchiveInputStream tis = new TarArchiveInputStream(is)) {
        TarArchiveEntry nextEntry;
        while ((nextEntry = tis.getNextTarEntry()) != null) {
            String name = nextEntry.getName();
            File file = new File(outPath, name);
            //如果是目录，创建目录
            if (nextEntry.isDirectory()) {
                file.mkdir();
            } else {
                //文件则写入具体的路径中
                FileUtils.copyToFile(tis, file);
                file.setLastModified(nextEntry.getLastModifiedDate().getTime());
            }
        }
    }
}



// 7z压缩
public void _7z() throws IOException {
    try (SevenZOutputFile outputFile = new SevenZOutputFile(new File("/test.7z"))) {
        File srcFile = new File("/test");
        _7zRecursive(outputFile, srcFile, "");
    }
}
// 递归压缩目录下的文件和目录
private void _7zRecursive(SevenZOutputFile _7zFile, File srcFile, String basePath) 
	throws IOException {
    if (srcFile.isDirectory()) {
        File[] files = srcFile.listFiles();
        String nextBasePath = basePath + srcFile.getName() + "/";
        // 空目录
        if (ArrayUtils.isEmpty(files)) {
            SevenZArchiveEntry entry = _7zFile.createArchiveEntry(srcFile, nextBasePath);
            _7zFile.putArchiveEntry(entry);
            _7zFile.closeArchiveEntry();
        } else {
            for (File file : files) {
                _7zRecursive(_7zFile, file, nextBasePath);
            }
        }
    } else {
        SevenZArchiveEntry entry = _7zFile.createArchiveEntry(srcFile, basePath + srcFile.getName());
        _7zFile.putArchiveEntry(entry);
        byte[] bs = FileUtils.readFileToByteArray(srcFile);
        _7zFile.write(bs);
        _7zFile.closeArchiveEntry();
    }
}
 // 7z解压
public void un7z() throws IOException {
    String outPath = "/test";
    try (SevenZFile archive = new SevenZFile(new File("test.7z"))) {
        SevenZArchiveEntry entry;
        while ((entry = archive.getNextEntry()) != null) {
            File file = new File(outPath, entry.getName());
            if (entry.isDirectory()) {
                file.mkdirs();
            }
            if (entry.hasStream()) {
                final byte [] buf = new byte [1024];
                final ByteArrayOutputStream baos = new ByteArrayOutputStream();
                for (int len = 0; (len = archive.read(buf)) > 0;) {
                    baos.write(buf, 0, len);
                }
                FileUtils.writeByteArrayToFile(file, baos.toByteArray());
            }
        }
    }
}
```

#### 3. 修改归档
```java
String tarFile = "/test.tar";
InputStream is = new FileInputStream(tarFile);
// 替换后会覆盖原test.tar，如果是windows可能会由于文件被访问而覆盖报错
OutputStream os = new FileOutputStream(tarFile);
try (TarArchiveInputStream tais = new TarArchiveInputStream(is);
     TarArchiveOutputStream taos = new TarArchiveOutputStream(os)) {
    ChangeSet changes = new ChangeSet();
    // 删除"test.tar中"的"dir/1.txt"文件
    changes.delete("dir/1.txt");
    // 删除"test.tar"中的"t"目录
    changes.delete("t");
    // 添加文件，如果已存在则替换
    File addFile = new File("/a.txt");
    ArchiveEntry addEntry = taos.createArchiveEntry(addFile, addFile.getName());
    // add可传第三个参数：true: 已存在则替换(默认值)， false: 不替换
    changes.add(addEntry, new FileInputStream(addFile));
    // 执行修改
    ChangeSetPerformer performer = new ChangeSetPerformer(changes);
    ChangeSetResults result = performer.perform(tais, taos);
}
```

#### 4. 其他
```java
//动态获取流
// 使用factory动态获取归档流
ArchiveStreamFactory factory = new ArchiveStreamFactory();
String archiveName = ArchiveStreamFactory.TAR;
InputStream is = new FileInputStream("/in.tar");
OutputStream os = new FileOutputStream("/out.tar");
// 动态获取实现类，此时ais实际上是TarArchiveOutPutStream
ArchiveInputStream ais = factory.createArchiveInputStream(archiveName, is);
ArchiveOutputStream aos = factory.createArchiveOutputStream(archiveName, os);

// 使用factory动态获取压缩流
CompressorStreamFactory factory = new CompressorStreamFactory();
String compressName = CompressorStreamFactory.GZIP;
InputStream is = new FileInputStream("/in.gz");
OutputStream os = new FileOutputStream("/out.gz");
// 动态获取实现类，此时ais实际上是TarArchiveOutPutStream
CompressorInputStream cis = factory.createCompressorInputStream(compressName, is);
CompressorOutputStream cos = factory.createCompressorOutputStream(compressName, os);

//同时解压解包压缩归档于一体的文件
// 解压 解包test.tar.gz文件
String outPath = "/test";
InputStream is = new FileInputStream("/test.tar.gz");
// 先解压，所以需要先用gzip流包装文件流
CompressorInputStream gis = new GzipCompressorInputStream(is);
// 在解包，用tar流包装gzip流
try (ArchiveInputStream tgis = new TarArchiveInputStream(gis)) {
    ArchiveEntry nextEntry;
    while ((nextEntry = tgis.getNextEntry()) != null) {
        String name = nextEntry.getName();
        File file = new File(outPath, name);
        // 如果是目录，创建目录
        if (nextEntry.isDirectory()) {
            file.mkdir();
        } else {
            // 文件则写入具体的路径中
            FileUtils.copyToFile(tgis, file);
            file.setLastModified(nextEntry.getLastModifiedDate().getTime());
        }
    }
}
```

### 5. Exec
```xml
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-exec</artifactId>
    <version>1.3</version>
</dependency>
```

#### 1. 基本调用
```java
//JDK原生写法
//不使用工具类的写法
Process process = Runtime.getRuntime().exec("cmd /c ping 192.168.1.10");
int exitCode = process.waitFor(); // 阻塞等待完成
if (exitCode == 0) { // 状态码0表示执行成功
    String result = IOUtils.toString(process.getInputStream());
    System.out.println(result);
} else {
    String errMsg = IOUtils.toString(process.getErrorStream());
    System.out.println(errMsg);
}

//process.waitFor会引起线程阻塞
//且如果命令行执行成功后的返回结果将缓冲区填满，无法写入数据则线程也会阻塞
//对外则表现为线程阻塞，命令不占资源也无反应
final Process process = Runtime.getRuntime().exec("cmd /c ping 192.168.1.10");
new Thread(() -> {
    try (BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()))) {
        String line;
        while ((line = br.readLine()) != null) {
            try {
                process.exitValue();
                break; // exitValue没有异常表示进程执行完成，退出循环
            } catch (IllegalThreadStateException e) {
                // 异常代表进程没有执行完
            }
            //此处只做输出，对结果有其他需求可以在主线程使用其他容器收集此输出
            System.out.println(line);
        }
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
}).start();
process.waitFor();
```

```java
//commons-exec则不需要考虑操作系统的平台（jdk Runtime.getRuntime().exec存在命令前缀，不同的操作系统有不同的命令前缀）
//且commons-exec能自定义输出流接受命令执行结果，能将输出流输入至字符串流、文件流、网络流等
String command = "ping 192.168.1.10";
//接收正常结果流
ByteArrayOutputStream susStream = new ByteArrayOutputStream();
//接收异常结果流
ByteArrayOutputStream errStream = new ByteArrayOutputStream();
//转换
CommandLine commandLine = CommandLine.parse(command);
DefaultExecutor exec = new DefaultExecutor();
PumpStreamHandler streamHandler = new PumpStreamHandler(susStream, errStream);
exec.setStreamHandler(streamHandler);
int code = exec.execute(commandLine);
System.out.println("result code: " + code);
// 不同操作系统注意编码，否则结果乱码
String suc = susStream.toString("GBK");
String err = errStream.toString("GBK");
System.out.println(suc);
System.out.println(err);
```

#### 2. 异步调用
```java
//JDK原生命令行异步调用写法
public class RuntimeAsyncDemo {

    public static void main(String[] args) throws Exception {
        System.out.println("1. 开始执行");
        String cmd = "cmd /c ping 192.168.1.11"; // 假设是一个耗时的操作
        execAsync(cmd, processResult -> {
            System.out.println("3. 异步执行完成，success=" + processResult.success + "; msg=" + processResult.result);
            System.exit(0);
        });
        // 做其他操作 ... ...
        System.out.println("2. 做其他操作");
        // 避免主线程退出导致程序退出
        Thread.currentThread().join();
    }
    private static void execAsync(String command, Consumer<ProcessResult> callback) throws IOException {
        final Process process = Runtime.getRuntime().exec(command);
        new Thread(() -> {
            StringBuilder successMsg = new StringBuilder();
            try (BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream(), "GBK"))) {
                // 存放临时结果
                String line;
                while ((line = br.readLine()) != null) {
                    try {
                        successMsg.append(line).append("\r\n");
                        int exitCode = process.exitValue();
                        ProcessResult pr = new ProcessResult();
                        if (exitCode == 0) {
                            pr.success = true;
                            pr.result = successMsg.toString();
                        } else {
                            pr.success = false;
                            pr.result = IOUtils.toString(process.getErrorStream());
                        }
                        callback.accept(pr); // 回调主线程注册的函数
                        break; // exitValue没有异常表示进程执行完成，退出循环
                    } catch (IllegalThreadStateException e) {
                        // 异常代表进程没有执行完
                    }
                    try {
                        // 等待100毫秒在检查是否完成
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }).start();
    }

    private static class ProcessResult {
        boolean success;
        String result;
    }
}
```

```java
//commons异步调用写法，commons-exec原生支持异步调用
public void execAsync() throws IOException, InterruptedException {
    String command = "ping 192.168.1.10";
    //接收正常结果流
    ByteArrayOutputStream susStream = new ByteArrayOutputStream();
    //接收异常结果流
    ByteArrayOutputStream errStream = new ByteArrayOutputStream();
    CommandLine commandLine = CommandLine.parse(command);
    DefaultExecutor exec = new DefaultExecutor();

    PumpStreamHandler streamHandler = new PumpStreamHandler(susStream, errStream);
    exec.setStreamHandler(streamHandler);
    ExecuteResultHandler erh = new ExecuteResultHandler() {
        @Override
        public void onProcessComplete(int exitValue) {
            try {
                String suc = susStream.toString("GBK");
                System.out.println(suc);
                System.out.println("3. 异步执行完成");
            } catch (UnsupportedEncodingException uee) {
                uee.printStackTrace();
            }
        }
        @Override
        public void onProcessFailed(ExecuteException e) {
            try {
                String err = errStream.toString("GBK");
                System.out.println(err);
                System.out.println("3. 异步执行出错");
            } catch (UnsupportedEncodingException uee) {
                uee.printStackTrace();
            }
        }
    };
    System.out.println("1. 开始执行");
    exec.execute(commandLine, erh);
    System.out.println("2. 做其他操作");
    // 避免主线程退出导致程序退出
    Thread.currentThread().join();
}
```

#### 3. 看门狗
```java
String command = "ping 192.168.1.10";
ByteArrayOutputStream susStream = new ByteArrayOutputStream();
ByteArrayOutputStream errStream = new ByteArrayOutputStream();
CommandLine commandLine = CommandLine.parse(command);
DefaultExecutor exec = new DefaultExecutor();
//设置一分钟超时
ExecuteWatchdog watchdog = new ExecuteWatchdog(60*1000);
exec.setWatchdog(watchdog);
PumpStreamHandler streamHandler = new PumpStreamHandler(susStream, errStream);
exec.setStreamHandler(streamHandler);
try {
    int code = exec.execute(commandLine);
    System.out.println("result code: " + code);
    // 不同操作系统注意编码，否则结果乱码
    String suc = susStream.toString("GBK");
    String err = errStream.toString("GBK");
    System.out.println(suc+err);
} catch (ExecuteException e) {
    if (watchdog.killedProcess()) {
        // 被watchdog故意杀死
        System.err.println("超时了");
    }
}
//ExecuteWatchdog可以通过destroyProcess()删除监控的进程
//可以通过killedProcess()查看监控的进程是否被杀死
```

### 6. Net
```xml
<dependency>
    <groupId>commons-net</groupId>
    <artifactId>commons-net</artifactId>
    <version>3.9.0</version>
</dependency>
```

#### 1. commons-net支持协议
**FTP/FTPS**：FTP（File Transfer Protocol，文件传输协议）是 TCP/IP 协议组中的协议之一。FTP协议包括两个组成部分，其一为FTP服务器，其二为FTP客户端。其中FTP服务器用来存储文件，用户可以使用FTP客户端通过FTP协议访问位于FTP服务器上的资源。在开发网站的时候，通常利用FTP协议把网页或程序传到Web服务器上。此外，由于FTP传输效率非常高，在网络上传输大的文件时，一般也采用该协议。实现该协议的类是**FTPClient/FTPSClient**

**FTP over HTTP** (experimental)：以http协议实现FTP的功能。由于FTP工作在被动模式时不仅需要将21作为FTP的控制（命令）端口，还要将20作为FTP的数据端口，因此在配置防火墙时比较麻烦，不如用http协议传输文件。因此可以利用原有的网站结合Alias的方法加目录访问控制来实现。实现该协议的类是**FTPHTTPClient**

**NNTP**：网络新闻组传输协议（Network News Transfer Protocol）是一个主要用于阅读和张贴新闻文章到Usenet上的Internet应用协议，也负责新闻在服务器间的传送。实现该协议的类是**NNTPClient**

**SMTP(S)**：SMTP（Simple Mail Transfer Protocol）是一种提供可靠且有效的电子邮件传输的协议。SMTP是建立在FTP文件传输服务上的一种邮件服务，主要用于系统之间的邮件信息传递，并提供有关来信的通知。实现该协议的类是**SMTPClient/SMTPSClient**

**POP3(S)**：POP3，全名为“Post Office Protocol - Version 3”，即“邮局协议版本3”。POP3协议允许电子邮件客户端下载服务器上的邮件，但是在客户端的操作（如移动邮件、标记已读等），不会反馈到服务器上。实现该协议的类是**POP3Client/POP3SClient**

**IMAP(S)**：IMAP（Internet Message Access Protocol）以前称作交互邮件访问协议（Interactive Mail Access Protocol），是一个应用层协议。它的主要作用是邮件客户端可以通过这种协议从邮件服务器上获取邮件的信息，下载邮件等。IMAP提供webmail 与电子邮件客户端之间的双向通信，客户端的操作都会反馈到服务器上，对邮件进行的操作，服务器上的邮件也会做相应的动作。实现该协议的类是**IMAPClient/IMAPSClient**

**Telnet**：Telnet协议是TCP/IP协议族中的一员，是Internet远程登录服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。Telnet是常用的远程控制Web服务器的方法。实现该协议的类是**TelnetClient**

**TFTP**：TFTP（Trivial File Transfer Protocol,简单文件传输协议）是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。端口号为69。实现该协议的类是**TFTPClient**

**Finger**：显示有关运行 Finger 服务或 Daemon 的指定远程计算机（通常是运行 UNIX 的计算机）上用户的信息。该远程计算机指定显示用户信息的格式和输出。实现该协议的类是**FingerClient**

**Whois**：whois 是用来查询域名的IP以及所有者等信息的传输协议。简单说，whois就是一个用来查询域名是否已经被注册，以及注册域名的详细信息的数据库（如域名所有人、域名注册商）。早期的whois查询多以命令行接口存在，但是现在出现了一些网页的线上查询工具，其仍依赖whois协议。命令行工具仍然被系统管理员广泛使用。whois通常使用TCP协议43端口。每个域名/IP的whois信息由对应的管理机构保存。实现该协议的类是**WhoisClient**

**rexec/rcmd/rlogin**：是一组Unix命令，远程执行，远程登录，起源于BSD系统。实现该协议的类是**RExecClient/RCommandClient/RLoginClient**

**Time** (rdate) / **Daytime**：**DAYTIME**协议是基于TCP的应用，是一种有用的调试工具，它的作用是返回当前时间和日期，格式是字符串格式。**Time**时间协议（英语：TIME protocol）是一个在RFC 868内定义的网络传输协议。它用作提供机器可读的日期时间信息。实现该协议的类是**TimeTCPClient/TimeUDPClient，DaytimeTCPClient/DaytimeUDPClient**

**Echo**：echo是一个计算机命令，它可以基于TCP协议，也可以基于UDP协议，服务器在端口7检测有无消息。是路由也是网络中最常用的数据包，可以通过发送echo包知道当前的连接节点有那些路径，并且通过往返时间能得出路径长度。实现该协议的类是**EchoTCPClient/EchoUDPClient**

**Discard**：抛弃协议，作用就是接收到什么抛弃什么，它对调试网络状态的一定的用处。实现该协议的类是**DiscardTCPClient/DiscardUDPClient**

**NTP/SNTP**：NTP服务器【Network Time Protocol（NTP）】是用来使计算机时间同步化的一种协议，它可以使计算机对其服务器或时钟源（如石英钟，GPS等等）做同步化。实现该协议的类是**NTPUDPClient**

### 7. Collections


## 6. SpringUtils


## 7. EasyExcel


## 8. Captcha

