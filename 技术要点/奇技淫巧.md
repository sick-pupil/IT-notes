## 1. Optional判空
```java
Optional.empty() //返回一个空的Optional

optional.isEmpty() //判断Optional是否为空，为空则返回true

Optional.of(obj) //返回一个非空的Optional，如果obj为空，则报错NullPointException

Optional.ofNullable(obj) //返回Optional，不管obj是否为空

optional.get() //返回Optional之前的obj值，如果不存在则报错NoSuchElementException

optional.isPreSent() //optional存在值则返回true，否则为null返回false

optional.ifPresent(arg -> {}) //optional存在值则调用其中的方法参数

optional.orElse(obj) //optional存在值则返回，否则返回orElse中的obj

optional.orElseGet(arg -> {}) //optional存在值则返回，否则调用orElseGet中的方法参数

optional.orElseThrow(arg -> {}) //optional存在值则返回，否则调用orElseThrow中的方法参数抛出异常

optional.map(arg -> {}) //根据方法参数中的返回值，返回一个对应的optional，即使用optional封装一遍属性

optional.flatMap(arg -> {}) //根据方法参数中的返回值，返回一个对应的optional，和map不同的是flatMap返回的对象如果已经是optional类型的，则不会再用optional封装一遍

optional.filter(arg -> {}) //方法参数返回true or false，如果返回true则返回一个带值的optional，否则返回一个空的optional
```

## 2. Stream集合操作
### 1. 创建流
```java
//collection.stream()和collection.parallelStream()，集合实例调用实例方法获取stream
List<String> list = new ArrayList<>();
Stream<String> stream = list.stream(); //获取顺序流
Stream<String> parallelStream = list.parallelStream(); //获取并行流

//Arrays.stream()，数组调用Arrays.stream()静态方法获取stream
Integer[] nums = new Integer[10];
Stream<Integer> stream = Arrays.stream(nums);

//调用Stream中的静态方法
//Stream.of()
Stream<Integer> ofStream = Stream.of(1,2,3,4,5,6);
Stream<String> ofStream = Stream.of("a", "b", "c", "d", "e", "f");
Stream<Bubble> ofStream = Stream.of(new Bubble(1), new Bubble(2), new Bubble(3), new Bubble(4), new Bubble(5), new Bubble(6));

//Stream.iterate()，iterate中第一个参数可以理解为seed种子，seed被作为参数代入iterate方法中的第二个参数lambda中，可以看出是无限流，最后需要limit作限制
Stream<Integer> iterateStream = Stream.iterate(0, (n) -> n + 2).limit(10);

//Stream.generate()，可以理解为和Stream.iterate差不多，也是无限流，只是参数形式不太一样
Stream<Double> generateStream = Stream.generate(Math::random).limit(2);

//bufferedReader.lines()，将读取的所有行内容转为流
BufferedReader reader = new BufferedReader(new FileReader("..."));
Stream<String> linesStream = reader.lines();

//pattern.splitAsStream()将字符串分隔成流
Pattern pattern = Pattern.compile(";");
Stream<String> splitStream = pattern.splitAsStream("a;b;c;d");
```

### 2. 流操作
```java
Stream<Integer> stream = Stream.of(1,2,3,4,5,6,7,8,9,10);

//filter()，按照filter中的lambda参数过滤出符合条件的stream元素集合
stream.filter(num -> num >= 5);

//limit(n)，获取n个元素的stream元素集合
stream.limit(2);

//skip(n)，跳过n个元素，配合limit(n)能实现分页
stream.skip(10);

//distinct()，根据流中元素的hashCode()和equals()去除重复元素
stream.distinct()

//map()，接受一个lambda方法，该方法被应用到每个元素上，可以修改原本stream中的每个元素
stream.map(i -> i + 2);

//flatMap()，接受一个lambda方法，该方法被应用到每个元素上，并且必须返回stream，flatMap会把lambda得到的多个stream合并成一个大stream
stream.flatMap(it -> it.getList().stream());

//sorted()，自然排序，流中元素需实现Comparable接口
stream.sorted()
//sorted(Comparator com)，流中元素按照Comparator排序器排序
stream.sorted((o1, o2) -> {return o1.getField() - o2.getField()})

//全部元素符合条件才返回true
allMatch
//全部元素都不符合条件才返回true
noneMatch
//只要有一个元素符合条件才返回true
anyMatch
//返回流中第一个元素
findFirst
//返回流中任意元素
findAny
//流中元素总个数
count
//流中元素最大值
max
//流中元素最小值
min
```

### 3. 流生成
```java
stream.collect()
//stream流中的元素进行汇总，转成集合
Collectors.toList()
Collectors.toSet()
Collectors.toCollection()
Collectors.toMap()
Collectors.collectingAndThen()
Collectors.joining()
Collectors.counting()
Collectors.summarizingDouble() Collectors.summarizingLong() Collectors.summarizingInt()
Collectors.averagingDouble() Collectors.averagingLong() Collectors.averagingInt()
Collectors.summingDouble() Collectors.summingLong() Collectors.summingint()
Collectors.maxBy() Collectors.minBy()
Collectors.groupingBy()
Collectors.partitioningBy()
```

## 3. Valid
`Validation`是用于检查程序代码中参数的有效性的框架，作为`Spring`中的一个参数校验工具，集成在`Spring-Context`中
- `@AssertFalse`：适用于`Boolean`，验证注解元素值为`false`
- `@AssertTrue`：适用于`Boolean`，验证注解元素值为`true`
- `@NotNull`：适用于任意类型，验证注解的元素值不是`null`
- `@Null`：适用于任意类型，验证注解的元素值是`null`
- `@Min(value=值)`：适用于`BigDecimal`、`BigInteger`、`byte`、`short`、`int`、`long`、`任意Number或存储数字的CharSequence`，验证注解的元素值大于等于`@Min`指定的`value`值
- `@Max(value=值)`：适用于`BigDecimal`、`BigInteger`、`byte`、`short`、`int`、`long`、`任意Number或存储数字的CharSequence`，验证注解的元素值小于等于`@Max`指定的`value`值
- `@DecimalMin(value=值)`：与`@Min`基本一致，但`value`可以填写`decimal`
- `@DecimalMax(value=值)`：与`@Max`基本一致，但`value`可以填写`decimal`
- `@Digits(integer=整数位数, fraction=小数位数)`：适用类型与`@Min`一致，但验证元素值的整数位数与小数位数
- `@Size(min=下限, max=上限)`：适用于字符串、`Collection`、`Map`、数组，验证字符串或者集合的大小上下限
- `@Past`：适用于`java.util.Date java.util.Calendar java.Time`类库的日期类型，验证注解的元素值（日期类型）比当前时间早
- `@Future`：适用于`java.util.Date java.util.Calendar java.Time`类库的日期类型，验证注解的元素值（日期类型）比当前时间晚
- `@NotBlank`：适用于`CharSequence`子类型，验证注解的元素值不为空（不为`null`、去除首位空格后长度为0），不同于`@NotEmpty`，`@NotBlank`只应用于字符串且在比较时会去除字符串的首位空格
- `@Length(min=下限, max=上限)`：适用于`CharSequence`子类型，验证注解的元素值长度在`min`和`max`区间内
- `@NotEmpty`：适用于`CharSequence`子类型、`Collection`、`Map`、数组，验证注解的元素值不为`null`且不为空（字符串长度不为0、集合大小不为0）
- `@Range(min=最小值, max=最大值)`：适用于`BigDecimal, BigInteger, CharSequence, byte, short, int, long`等原子类型和包装类型，验证注解的元素值在最小值和最大值之间
- `@Email(regexp=正则表达式,flag=标志的模式)`
- `@Pattern(regexp=正则表达式,flag=标志的模式)`
- `@Valid`：指定递归验证关联的对象；如用户对象中有个地址对象属性，如果想在验证用户对象时一起验证地址对象的话，在地址对象上加`@Valid`注解即可级联验证

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```

```java
/**
 * 用户类
 */
@Setter
@Getter
@NoArgsConstructor
public class User implements Serializable {

   /**
    * 主键id
    */
   private Integer id;

   /**
    * 用户名
    */
   @NotEmpty(message = "用户名不能为空！")
   private String username;

   /**
    * 密码
    */
   @Size(min = 8, message = "密码长度不能小于8！")
   @NotEmpty(message = "密码不能为空！")
   private String password;

   /**
    * 邮箱
    */
   @Email(message = "邮箱格式错误！")
   private String email;

   /**
    * 年龄
    */
   @Min(value = 18, message = "年龄不能小于18！")
   @Max(value = 150, message = "年龄不能小于150！")
   private int age;

}

@PostMapping("/add")
public String add(@RequestBody @Valid User user, BindingResult errors) {
   if (errors.hasErrors()) {
      return errors.getFieldError().getDefaultMessage();
   }
   userService.add(user);
   return "添加成功！";
}
```

`Controller`方法参数中多了一个`BindingResult`类型的参数，该对象存放`validation`校验的错误信息，一般通过`hasErrors`方法判断是否有错误，通过`errors.getFieldError().getDefaultMessage()`获取错误信息

同为一个需要校验的类或者对象，可能在一个业务场景需要做A类型的校验，而在另一个业务场景需要做B类型的校验（`User`类，在`userAdd`接口需要`password`不为空，而在`userUpdate`接口则不需要填写`password`）

```java
package com.example.validationtest.param;

/**
 * 校验规则类
 */
public class ValidationRules {

   /**
    * 注册（添加）用户规则
    */
   public interface UserAdd {

   }

   /**
    * 更新（修改）用户规则
    */
   public interface UserUpdate {

   }

}


package com.example.validationtest.dataobject;

import com.example.validationtest.param.ValidationRules;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import javax.validation.constraints.*;
import java.io.Serializable;

/**
 * 用户类
 */
@Setter
@Getter
@NoArgsConstructor
public class User implements Serializable {

   /**
    * 主键id，将其设定分组为ValidationRules.UserUpdate，表示用户信息修改时校验该规则
    */
   @NotNull(groups = ValidationRules.UserUpdate.class, message = "用户id不能为空！")
   private Integer id;

   /**
    * 用户名，将其设定分组为ValidationRules.UserAdd，表示添加用户时校验该规则
    */
   @NotEmpty(groups = ValidationRules.UserAdd.class, message = "用户名不能为空！")
   private String username;

   /**
    * 密码，将长度校验规则同时加入到ValidationRules.UserAdd和ValidationRules.UserUpdate组，表示添加用户和用户信息修改时都要校验这个规则，空值校验只有添加时校验
    */
   @Size(groups = {ValidationRules.UserAdd.class, ValidationRules.UserUpdate.class}, 
	   min = 8, message = "密码长度不能小于8！")
   @NotEmpty(groups = ValidationRules.UserAdd.class, message = "密码不能为空！")
   private String password;

   // 下面都是一回事

   /**
    * 邮箱
    */
   @Email(groups = {ValidationRules.UserAdd.class, ValidationRules.UserUpdate.class}, 
	   message = "邮箱格式错误！")
   private String email;

   /**
    * 年龄
    */
   @Min(groups = {ValidationRules.UserAdd.class, ValidationRules.UserUpdate.class}, 
	   value = 18, message = "年龄不能小于18！")
   @Max(groups = {ValidationRules.UserAdd.class, ValidationRules.UserUpdate.class}, 
	   value = 150, message = "年龄不能小于150！")
   private int age;

}


package com.example.validationtest.api;

import com.example.validationtest.dataobject.User;
import com.example.validationtest.param.ValidationRules;
import org.springframework.validation.BindingResult;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * 测试校验（这里不做实际的用户添加删除工作，只是测试validation校验）
 */
@RestController
@RequestMapping("/api/user")
public class UserAPI {

   /**
    * 模拟添加用户，这里设置校验规则为ValidationRules.UserAdd
    */
   @PostMapping("/add")
   public String add(@RequestBody @Validated(ValidationRules.UserAdd.class) User user, 
	   BindingResult errors) {
      if (errors.hasErrors()) {
         return errors.getFieldError().getDefaultMessage();
      }
      return "添加成功！";
   }

   /**
    * 模拟修改用户，这里设置校验规则为ValidationRules.UserUpdate
    */
   @PostMapping("/update")
   public String update(@RequestBody @Validated(ValidationRules.UserUpdate.class) User user, 
	   BindingResult errors) {
      if (errors.hasErrors()) {
         return errors.getFieldError().getDefaultMessage();
      }
      return "修改成功！";
   }
}
```

## 4. Hutool
### 1. 日期时间
#### 1. DateUtil
```java
//Date、Long、Calendar类型互相转换
//当前时间
Date date = DateUtil.date();
//当前时间
Date date2 = DateUtil.date(Calendar.getInstance());
//当前时间
Date date3 = DateUtil.date(System.currentTimeMillis());
//当前时间字符串，格式：yyyy-MM-dd HH:mm:ss
String now = DateUtil.now();
//当前日期字符串，格式：yyyy-MM-dd
String today= DateUtil.today();


//格式化
String dateStr = "2017-03-01";
Date date = DateUtil.parse(dateStr);
//结果 2017/03/01
String format = DateUtil.format(date, "yyyy/MM/dd");
//常用格式的格式化，结果：2017-03-01
String formatDate = DateUtil.formatDate(date);
//结果：2017-03-01 00:00:00
String formatDateTime = DateUtil.formatDateTime(date);
//结果：00:00:00
String formatTime = DateUtil.formatTime(date);


//日期时间部分获取
Date date = DateUtil.date();
//获得年的部分
DateUtil.year(date);
//获得月份，从0开始计数
DateUtil.month(date);
//获得月份枚举
DateUtil.monthEnum(date);


//开始结束日期时间
String dateStr = "2017-03-01 22:33:23";
Date date = DateUtil.parse(dateStr);
//一天的开始，结果：2017-03-01 00:00:00
Date beginOfDay = DateUtil.beginOfDay(date);
//一天的结束，结果：2017-03-01 23:59:59
Date endOfDay = DateUtil.endOfDay(date);


//时间加减计算、偏移
String dateStr = "2017-03-01 22:33:23";
Date date = DateUtil.parse(dateStr);
//结果：2017-03-03 22:33:23
Date newDate = DateUtil.offset(date, DateField.DAY_OF_MONTH, 2);
//常用偏移，结果：2017-03-04 22:33:23
DateTime newDate2 = DateUtil.offsetDay(date, 3);
//常用偏移，结果：2017-03-01 19:33:23
DateTime newDate3 = DateUtil.offsetHour(date, -3);
//昨天
DateUtil.yesterday()
//明天
DateUtil.tomorrow()
//上周
DateUtil.lastWeek()
//下周
DateUtil.nextWeek()
//上个月
DateUtil.lastMonth()
//下个月
DateUtil.nextMonth()


//日期时间差
String dateStr1 = "2017-03-01 22:33:23";
Date date1 = DateUtil.parse(dateStr1);
String dateStr2 = "2017-04-01 23:33:23";
Date date2 = DateUtil.parse(dateStr2);
//相差一个月，31天
long betweenDay = DateUtil.between(date1, date2, DateUnit.DAY);
//Level.MINUTE表示精确到分
String formatBetween = DateUtil.formatBetween(between, Level.MINUTE);
//输出：31天1小时
Console.log(formatBetween);
```

#### 2. DateTime
```java
Date date = new Date();
//new方式创建
DateTime time = new DateTime(date);
Console.log(time);
//of方式创建
DateTime now = DateTime.now();
DateTime dt = DateTime.of(date);


//日期时间部分获取
DateTime dateTime = new DateTime("2017-01-05 12:34:23", DatePattern.NORM_DATETIME_FORMAT);
//年，结果：2017
int year = dateTime.year();
//季度（非季节），结果：Season.SPRING
Season season = dateTime.seasonEnum();
//月份，结果：Month.JANUARY
Month month = dateTime.monthEnum();
//日，结果：5
int day = dateTime.dayOfMonth();


//DateTime为可变对象，可设置为不可变对象
DateTime dateTime = new DateTime("2017-01-05 12:34:23", DatePattern.NORM_DATETIME_FORMAT);
//默认情况下DateTime为可变对象，此时offset == dateTime
DateTime offset = dateTime.offset(DateField.YEAR, 0);
//设置为不可变对象后变动将返回新对象，此时offset != dateTime
dateTime.setMutable(false);
offset = dateTime.offset(DateField.YEAR, 0);
```

### 2. 加密解密
```java
//hex 16进制加密解密
String str = "我是一个字符串";
String hex = HexUtil.encodeHexStr(str, CharsetUtil.CHARSET_UTF_8);
//hex是：
//e68891e698afe4b880e4b8aae5ad97e7aca6e4b8b2
String decodedStr = HexUtil.decodeHexStr(hex);
//解码后与str相同


//base62
String a = "伦家是一个非常长的字符串66";
// 17vKU8W4JMG8dQF8lk9VNnkdMOeWn4rJMva6F0XsLrrT53iKBnqo
String encode = Base62.encode(a);
// 还原为a
String decodeStr = Base62.decodeStr(encode);


//base64
String a = "伦家是一个非常长的字符串";
//5Lym5a625piv5LiA5Liq6Z2e5bi46ZW/55qE5a2X56ym5Liy
String encode = Base64.encode(a);
// 还原为a
String decodeStr = Base64.decodeStr(encode);


//base32
String a = "伦家是一个非常长的字符串";
String encode = Base32.encode(a);
Assert.assertEquals("4S6KNZNOW3TJRL7EXCAOJOFK5GOZ5ZNYXDUZLP7HTKCOLLMX46WKNZFYWI", encode);
String decodeStr = Base32.decodeStr(encode);
Assert.assertEquals(a, decodeStr);


//AES
String content = "test中文";
//随机生成密钥
byte[] key = SecureUtil.generateKey(SymmetricAlgorithm.AES.getValue()).getEncoded();
//构建
SymmetricCrypto aes = new SymmetricCrypto(SymmetricAlgorithm.AES, key);
//加密
byte[] encrypt = aes.encrypt(content);
//解密
byte[] decrypt = aes.decrypt(encrypt);
//加密为16进制表示
String encryptHex = aes.encryptHex(content);
//解密为字符串
String decryptStr = aes.decryptStr(encryptHex, CharsetUtil.CHARSET_UTF_8);


//DESede
String content = "test中文";
byte[] key = SecureUtil.generateKey(SymmetricAlgorithm.DESede.getValue()).getEncoded();
SymmetricCrypto des = new SymmetricCrypto(SymmetricAlgorithm.DESede, key);
//加密
byte[] encrypt = des.encrypt(content);
//解密
byte[] decrypt = des.decrypt(encrypt);
//加密为16进制字符串（Hex表示）
String encryptHex = des.encryptHex(content);
//解密为字符串
String decryptStr = des.decryptStr(encryptHex);


//RSA
RSA rsa = new RSA();
//获得私钥
rsa.getPrivateKey();
rsa.getPrivateKeyBase64();
//获得公钥
rsa.getPublicKey();
rsa.getPublicKeyBase64();
//公钥加密，私钥解密
byte[] encrypt = rsa.encrypt(StrUtil.bytes("我是一段测试aaaa", CharsetUtil.CHARSET_UTF_8), KeyType.PublicKey);
byte[] decrypt = rsa.decrypt(encrypt, KeyType.PrivateKey);
//私钥加密，公钥解密
byte[] encrypt2 = rsa.encrypt(StrUtil.bytes("我是一段测试aaaa", CharsetUtil.CHARSET_UTF_8), KeyType.PrivateKey);
byte[] decrypt2 = rsa.decrypt(encrypt2, KeyType.PublicKey);
```

### 3. HTTP
```java
//GET
// 最简单的HTTP请求，可以自动通过header等信息判断编码，不区分HTTP和HTTPS
String result1= HttpUtil.get("https://www.baidu.com");
// 当无法识别页面编码的时候，可以自定义请求页面的编码
String result2= HttpUtil.get("https://www.baidu.com", CharsetUtil.CHARSET_UTF_8);
//可以单独传入http参数，这样参数会自动做URL编码，拼接在URL中
HashMap<String, Object> paramMap = new HashMap<>();
paramMap.put("city", "北京");
String result3= HttpUtil.get("https://www.baidu.com", paramMap);


//POST
HashMap<String, Object> paramMap = new HashMap<>();
paramMap.put("city", "北京");
String result= HttpUtil.post("https://www.baidu.com", paramMap);


//文件上传
HashMap<String, Object> paramMap = new HashMap<>();
//文件上传只需将参数中的键指定（默认file），值设为文件对象即可，对于使用者来说，文件上传与普通表单提交并无区别
paramMap.put("file", FileUtil.file("D:\\face.jpg"));
String result= HttpUtil.post("https://www.baidu.com", paramMap);


//文件下载
String fileUrl = "http://mirrors.sohu.com/centos/8.4.2105/isos/x86_64/CentOS-8.4.2105-x86_64-dvd1.iso";
//将文件下载后保存在E盘，返回结果为下载文件大小
long size = HttpUtil.downloadFile(fileUrl, FileUtil.file("e:/"));
System.out.println("Download size: " + size);


String result2 = HttpRequest.post(url)
    .header(Header.USER_AGENT, "Hutool http")//头信息，多个头信息多次调用此方法即可
    .form(paramMap)//表单内容
    .timeout(20000)//超时，毫秒
    .execute().body();
Console.log(result2);

String json = ...;
String result2 = HttpRequest.post(url)
    .body(json)
    .execute().body();

HttpResponse res = HttpRequest.post(url)..execute();
Console.log(res.getStatus());

HttpResponse res = HttpRequest.post(url)..execute();
//预定义的头信息
Console.log(res.header(Header.CONTENT_ENCODING));
//自定义头信息
Console.log(res.header("Content-Disposition"));


```

### 4. 命令行
```java
String str = RuntimeUtil.execForStr("ipconfig");
List<String> strList = RuntimeUtil.execForStr("ipconfig");
```

### 5. ID
```java
//UUID
//生成的UUID是带-的字符串，类似于：a5c8a5e8-df2b-4706-bea4-08d0939410e3
String uuid = IdUtil.randomUUID();
//生成的是不带-的字符串，类似于：b17f24ff026d40949c85a24f4f375d42
String simpleUUID = IdUtil.simpleUUID();


//ObjectId
//生成类似：5b9e306a4df4f8c54a39fb0c
String id = ObjectId.next();
//方法2：从Hutool-4.1.14开始提供
String id2 = IdUtil.objectId();


//Snowflake
//参数1为终端ID
//参数2为数据中心ID
Snowflake snowflake = IdUtil.getSnowflake(1, 1);
long id = snowflake.nextId();
//简单使用
long id = IdUtil.getSnowflakeNextId();
String id = snowflake.getSnowflakeNextIdStr();
```

## 5. Apache-Commons
### 1. Lang
<img src="D:\Project\IT-notes\技术要点\img\apache-commons-lang.png" style="width:700px;height:350px;" />

#### 1. 日期时间
##### 1. 字符串转日期
```java
final String strDate = "2021-07-04 11:11:11";
final String pattern = "yyyy-MM-dd HH:mm:ss";
Date date2 = DateUtils.parseDate(strDate, pattern);
```

##### 2. 日期转字符串
```java
final Date date = new Date();
final String pattern = "yyyy年MM月dd日";
String strDate = DateFormatUtils.format(date, pattern);
```

##### 3. 日期计算
```java
final Date date = new Date();
Date newDate1 = DateUtils.addDays(date, 5); // 加5天
Date newDate2 = DateUtils.addHours(date, -5); // 减5小时
Date newDate3 = DateUtils.truncate(date, Calendar.DATE); // 过滤时分秒
boolean isSameDay = DateUtils.isSameDay(newDate1, newDate2); // 判断是否是同一天
```

#### 2. 字符串
##### 1. 判空
```java
//判空
boolean isEmpty = StringUtils.isEmpty(str);
boolean isNotEmpty = StringUtils.isNotEmpty(str);
//去除空格后判空
boolean isBlank = StringUtils.isBlank(str);
boolean isNotBlank = StringUtils.isNotBlank(str);
//只要有一个为空则true
boolean isAnyEmpty = StringUtils.isAnyEmpty(str1, str2, str3);
//所有都为空则true
boolean isAllEmpty = StringUtils.isAllEmpty(str1, str2, str3);
```

##### 2. 去空格
```java
//去除两侧空格并返回新字符串
String newStr = StringUtils.trim();
//去除两侧空格后如果为null则返回空字符串
newStr = StringUtils.trimToEmpty(str);
//去除两侧空格后如果为空字符串则返回null
newStr = StringUtils.trimToNull(str);
//去除两侧指定的任意字符，如去除两侧的'a' 'b' 'c'字符
newStr = StringUtils.strip(str, "abc");
//去除左侧指定的任意字符
newStr = StringUtils.stripStart(str, "abc");
//去除右侧指定的任意字符
newStr = StringUtils.stripEnd(str, "abc");
```

##### 3. 分割
```java
//默认指定空格为分隔符
StringUtils.split(str);
//指定分隔符并分割字符串
StringUtils.split(str, ",");
```

##### 4. 取子字符串
```java
//获得"aa.bb.cc"字符串中最后一个'.'之前的字符串
StringUtils.substringBeforeLast("aa.bb.cc", "."); //aa.bb
//获得"aa.bb.cc"字符串中最后一个'.'之后的字符串
StringUtils.substringAfterLast("aa.bb.cc", "."); //cc
//获得"aa.bb.cc"字符串中第一个'.'之前的字符串
StringUtils.substringBefore("aa.bb.cc", "."); //aa
//获得"aa.bb.cc"字符串中第一个'.'之后的字符串
StringUtils.substringAfter("aa.bb.cc", "."); //cc
// 获取"ab.cc.txt"中.之间的字符串
StringUtils.substringBetween("ab.cc.txt", "."); //cc
StringUtils.substringBetween("a(bb)c", "(", ")"); //bb
```

##### 5. 其他
```java
// 首字母大写
StringUtils.capitalize("test"); // Test
// 字符串合并
StringUtils.join(new int[]{1,2,3}, ",");// 1,2,3
// 缩写
StringUtils.abbreviate("abcdefg", 6);// "abc..."
// 判断字符串是否是数字
StringUtils.isNumeric("abc123");// false
// 删除指定字符
StringUtils.remove("abbc", "b"); // ac

// 随机生成长度为5的字符串
RandomStringUtils.random(5);
// 随机生成长度为5的"只含大小写字母"字符串
RandomStringUtils.randomAlphabetic(5);
// 随机生成长度为5的"只含大小写字母和数字"字符串
RandomStringUtils.randomAlphanumeric(5);
// 随机生成长度为5的"只含数字"字符串
RandomStringUtils.randomNumeric(5);
```

#### 3. 反射
```java
//读写属性
String value2 = (String) FieldUtils.readDeclaredField(reflectDemo, "abc", true); //123
public class ReflectDemo {
    private static String sAbc = "111";
    private String abc = "123";
    public void fieldRelated() throws Exception {
        ReflectDemo reflectDemo = new ReflectDemo();
        // 反射获取对象属性的值
        String value2 = (String) FieldUtils.readField(reflectDemo, "abc", true);//123
        // 反射获取类静态属性的值
        String value3 = (String) FieldUtils.readStaticField(ReflectDemo.class, "sAbc", true);//111
        // 反射设置对象属性值
        FieldUtils.writeField(reflectDemo, "abc", "newValue", true);
        // 反射设置类静态属性的值
        FieldUtils.writeStaticField(ReflectDemo.class, "sAbc", "newStaticValue", true);
    }
}

//获取被注解注释的方法
// 原生写法
List<Method> annotatedMethods = new ArrayList<Method>();
for (Method method : ReflectDemo.class.getMethods()) {
    if (method.getAnnotation(Test.class) != null) {
        annotatedMethods.add(method);
    }
}
// commons写法
Method[] methods = MethodUtils.getMethodsWithAnnotation(ReflectDemo.class, Test.class);


//调用方法
private static void testStaticMethod(String param1) {}
private void testMethod(String param1) {}
public void invokeDemo() throws Exception {
    // 调用函数"testMethod"
    ReflectDemo reflectDemo = new ReflectDemo();
    // 原生写法
    Method testMethod = reflectDemo.getClass().getDeclaredMethod("testMethod");
    testMethod.setAccessible(true); // 设置访问级别，如果private函数不设置则调用会报错
    testMethod.invoke(reflectDemo, "testParam");
    // commons写法
    MethodUtils.invokeExactMethod(reflectDemo, "testMethod", "testParam");
    
    // ---------- 类似方法 ----------
    // 调用static方法
    MethodUtils.invokeExactStaticMethod(ReflectDemo.class, "testStaticMethod", "testParam");
    // 调用方法(含继承过来的方法)
    MethodUtils.invokeMethod(reflectDemo, "testMethod", "testParam");
    // 调用static方法(当前不存在则向父类寻找匹配的静态方法)
    MethodUtils.invokeStaticMethod(ReflectDemo.class, "testStaticMethod", "testParam");
}
```

#### 4. 系统
```java
// 判断操作系统类型
boolean isWin = SystemUtils.IS_OS_WINDOWS;
boolean isWin10 = SystemUtils.IS_OS_WINDOWS_10;
boolean isWin2012 = SystemUtils.IS_OS_WINDOWS_2012;
boolean isMac = SystemUtils.IS_OS_MAC;
boolean isLinux = SystemUtils.IS_OS_LINUX;
boolean isUnix = SystemUtils.IS_OS_UNIX;
boolean isSolaris = SystemUtils.IS_OS_SOLARIS;
// ... ...

// 判断java版本
boolean isJava6 = SystemUtils.IS_JAVA_1_6;
boolean isJava8 = SystemUtils.IS_JAVA_1_8;
boolean isJava11 = SystemUtils.IS_JAVA_11;
boolean isJava14 = SystemUtils.IS_JAVA_14;
// ... ...

// 获取java相关目录
File javaHome = SystemUtils.getJavaHome();
File userHome = SystemUtils.getUserHome();// 操作系统用户目录
File userDir = SystemUtils.getUserDir();// 项目所在路径
File tmpDir = SystemUtils.getJavaIoTmpDir();
```

### 2. IO
<img src="D:\Project\IT-notes\技术要点\img\apache-commons-io.png" style="width:700px;height:250px;" />

#### 1. 输入输出流
```java
InputStream inputStream = new FileInputStream("test.txt");
OutputStream outputStream = new FileOutputStream("test.txt");
// 原生写法
if (inputStream != null) {
    try {
        inputStream.close();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
if (outputStream != null) {
    try {
        outputStream.close();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
// commons写法(可以传任意数量的流)
IOUtils.closeQuietly(inputStream, outputStream);


// ==== 输入流转换为byte数组 ====
// 原生写法
InputStream is = new FileInputStream("foo.txt");
byte[] buf = new byte[1024];
int len;
ByteArrayOutputStream out = new ByteArrayOutputStream();
while ((len = is.read(buf)) != -1) {
    out.write(buf, 0, len);
}
byte[] result = out.toByteArray();
// commons写法，输入流读出字节
byte[] result2 = IOUtils.toByteArray(is);
// commons写法，输入流读出字符串
String result2 = IOUtils.toString(is, "UTF-8");
// 将reader转换为字符串
String toString(Reader reader, String charset) throws IOException;
// 将url转换为字符串，也就是可以直接将网络上的内容下载为字符串
String toString(URL url, String charset) throws IOException;


// 按照行读取结果
InputStream is = new FileInputStream("test.txt");
List<String> lines = IOUtils.readLines(is, "UTF-8");

// 将行集合写入输出流
OutputStream os = new FileOutputStream("newTest.txt");
IOUtils.writeLines(lines, System.lineSeparator(), os, "UTF-8");

// 拷贝输入流到输出流
InputStream inputStream = new FileInputStream("src.txt");
OutputStream outputStream = new FileOutputStream("dest.txt");
IOUtils.copy(inputStream, outputStream);

//自动关闭输入流
InputStream is = new FileInputStream("test.txt");
AutoCloseInputStream acis = new AutoCloseInputStream(is);
IOUtils.toByteArray(acis); // 将流全部读完

// 从后向前按行读取
try (ReversedLinesFileReader reader = new ReversedLinesFileReader(new File("test.txt"), Charset.forName("UTF-8"))) {
    String lastLine = reader.readLine(); // 读取最后一行
    List<String> line5 = reader.readLines(5); // 从后再读5行
}

//计数流
InputStream is = new FileInputStream("test.txt");
try (CountingInputStream cis = new CountingInputStream(is)) {
	String txt = IOUtils.toString(cis, "UTF-8"); // 文件内容
	long size = cis.getByteCount(); // 读取的字节数
} catch (IOException e) {
	// 异常处理
}


//可观察的输入流（典型的观察者模式），可实现边读取边处理
private class MyObservableInputStream extends ObservableInputStream {
    class MyObserver extends Observer {
        @Override
        public void data(final int input) throws IOException {
            // 做自定义处理
        }
        @Override
        public void data(final byte[] input, final int offset, final int length) throws IOException {
            // 做自定义处理
        }
    }
    public MyObservableInputStream(InputStream inputStream) {
        super(inputStream);
    }
}


//BOMInputStream: 同时读取文本文件的bom头

//BoundedInputStream：有界的流，控制只允许读取前x个字节

//BrokenInputStream: 一个错误流，永远抛出IOException

//CharSequenceInputStream: 支持StringBuilder,StringBuffer等读取

//LockableFileWriter: 带锁的Writer，同一个文件同时只允许一个流写入，多余的写入操作会跑出IOException

//StringBuilderWriter: StringBuilder的Writer
```

#### 2. 文件读写
**FileUtils、FilenameUtils、PathUtils**
```java
File readFile = new File("test.txt");
// 读取文件
String str = FileUtils.readFileToString(readFile, "UTF-8");
// 读取文件为字节数组
byte[] bytes = FileUtils.readFileToByteArray(readFile);
// 按行读取文件
List<String> lines =  FileUtils.readLines(readFile, "UTF-8");

File writeFile = new File("out.txt");
// 将字符串写入文件
FileUtils.writeStringToFile(writeFile, "测试文本", "UTF-8");
// 将字节数组写入文件
FileUtils.writeByteArrayToFile(writeFile, bytes);
// 将字符串列表一行一行写入文件
FileUtils.writeLines(writeFile, lines, "UTF-8");
```

#### 3. 文件移动复制
```java
File srcFile = new File("src.txt");
File destFile = new File("dest.txt");
File srcDir = new File("/srcDir");
File destDir = new File("/destDir");
// 移动/拷贝文件
FileUtils.moveFile(srcFile, destFile);
FileUtils.copyFile(srcFile, destFile);
// 移动/拷贝文件到目录
FileUtils.moveFileToDirectory(srcFile, destDir, true);
FileUtils.copyFileToDirectory(srcFile, destDir);
// 移动/拷贝目录
FileUtils.moveDirectory(srcDir, destDir);
FileUtils.copyDirectory(srcDir, destDir);
// 拷贝网络资源到文件
FileUtils.copyURLToFile(new URL("http://xx"), destFile);
// 拷贝流到文件
FileUtils.copyInputStreamToFile(new FileInputStream("test.txt"), destFile);
```

#### 4. 文件名
```java
// 获取名称，后缀等
String name = "/home/xxx/test.txt";
FilenameUtils.getName(name); // "test.txt"
FilenameUtils.getBaseName(name); // "test"
FilenameUtils.getExtension(name); // "txt"
FilenameUtils.getPath(name); // "/home/xxx/"
```

#### 5. Path
```java
// 获取当前路径
Path path = PathUtils.current();
// 删除path
PathUtils.delete(path);
// 路径或文件是否为空
PathUtils.isEmpty(path);
// 设置只读
PathUtils.setReadOnly(path, true);
// 复制
PathUtils.copyFileToDirectory(Paths.get("test.txt"), path);
PathUtils.copyDirectory(Paths.get("/srcPath"), Paths.get("/destPath"));
// 统计目录内文件数量
Counters.PathCounters counters = PathUtils.countDirectory(path);
counters.getByteCounter(); // 字节大小
counters.getDirectoryCounter(); // 目录个数
counters.getFileCounter(); // 文件个数
```

#### 6. 文件排序器
```java
List<File> files = Arrays.asList(new File[]{
        new File("/foo/def"),
        new File("/foo/test.txt"),
        new File("/foo/abc"),
        new File("/foo/hh.txt")});
// 排序目录在前
Collections.sort(files, DirectoryFileComparator.DIRECTORY_COMPARATOR); // ["/foo/def", "/foo/abc", "/foo/test.txt", "/foo/hh.txt"]
// 排序目录在后
Collections.sort(files, DirectoryFileComparator.DIRECTORY_REVERSE); // ["/foo/test.txt", "/foo/hh.txt", "/foo/def", "/foo/abc"]
// 组合排序，首先按目录在前排序，其次再按照名称排序
Comparator dirAndNameComp = new CompositeFileComparator(
            DirectoryFileComparator.DIRECTORY_COMPARATOR,
            NameFileComparator.NAME_COMPARATOR);
Collections.sort(files, dirAndNameComp); // ["/foo/abc", "/foo/def", "/foo/hh.txt", "/foo/test.txt"]
```

#### 7. 文件监听器
```java
public static void main(String[] args) throws Exception {
    // 监听目录下文件变化。可通过参数控制监听某些文件，默认监听目录所有文件
    FileAlterationObserver observer = new FileAlterationObserver("/foo");
    observer.addListener(new myListener());
    FileAlterationMonitor monitor = new FileAlterationMonitor();
    monitor.addObserver(observer);
    monitor.start(); // 启动监视器
    Thread.currentThread().join(); // 避免主线程退出造成监视器退出
}

private class myListener extends FileAlterationListenerAdaptor {
    @Override
    public void onFileCreate(File file) {
        System.out.println("fileCreated:" + file.getAbsolutePath());
    }
    @Override
    public void onFileChange(File file) {
        System.out.println("fileChanged:" + file.getAbsolutePath());
    }
    @Override
    public void onFileDelete(File file) {
        System.out.println("fileDeleted:" + file.getAbsolutePath());
    }
}
```

#### 8. 其他
```java
File file = new File("test.txt");
File dir = new File("/test");
// 删除文件
FileUtils.delete(file);
// 删除目录
FileUtils.deleteDirectory(dir);
// 文件大小，如果是目录则递归计算总大小
long s = FileUtils.sizeOf(file);
// 则递归计算目录总大小，参数不是目录会抛出异常
long sd = FileUtils.sizeOfDirectory(dir);
// 递归获取目录下的所有文件
Collection<File> files = FileUtils.listFiles(dir, null, true);
// 获取jvm中的io临时目录
FileUtils.getTempDirectory();
```

### 3. Codec
<img src="D:\Project\IT-notes\技术要点\img\apache-commons-codec.png" style="width:700px;height:200px;" />

#### 1. Hex
```java
// byte数组转为16进制字符串
String hex = Hex.encodeHexString("123".getBytes());
System.out.println(hex);
// 16进制字符串解码
byte[] src = Hex.decodeHex(hex);
System.out.println(new String(src));
```

#### 2. Base64/Base32/Base16
```java
// base64编码
String base64 = Base64.encodeBase64String("测试".getBytes());
System.out.println(base64);
// base64解码
byte[] src = Base64.decodeBase64(base64);
System.out.println(new String(src));
// 字符串是否是base64
Base64.isBase64(base64);



// 以流方式提供Base64编码和解码
// 附："123"的base64编码为"MTIz"
// 对输入流做base64编码
InputStream is = new ByteArrayInputStream("123".getBytes());
Base64InputStream ebis = new Base64InputStream(is, true);
String enc = IOUtils.toString(ebis, "UTF-8"); // MTIz
// 对base64数据流做解码
is = new ByteArrayInputStream(enc.getBytes());
Base64InputStream dbis = new Base64InputStream(is, false);
String dec = IOUtils.toString(dbis, "UTF-8"); // 123

// 将数据做base64编码写入输出流
final String data = "123";
ByteArrayOutputStream baos = new ByteArrayOutputStream();
Base64OutputStream ebos = new Base64OutputStream(baos, true);
IOUtils.write(data, ebos, "UTF-8");
String enc2 = baos.toString(); // MTIz
// 将base64数据做解码写入输出流
baos = new ByteArrayOutputStream();
Base64OutputStream dbos = new Base64OutputStream(baos, false);
IOUtils.write(data, dbos, "UTF-8");
String dec2 = dbos.toString(); // 123
```

#### 3. URL
```java
URLCodec urlCodec = new URLCodec();
// url编码
String encUrl = urlCodec.encode("http://x.com?f=哈");
System.out.println(encUrl);
// url解码
String decUrl = urlCodec.decode(encUrl);
System.out.println(decUrl);
```

#### 4. MD/SHA/HMAC
```java
String md5 = DigestUtils.md5Hex("测试");

String sha1 = DigestUtils.sha1Hex("测试");
String sha256 = DigestUtils.sha256Hex("测试");
String sha384 = DigestUtils.sha384Hex("测试");
String sha512 = DigestUtils.sha512Hex("测试");
String sha3_256 = DigestUtils.sha3_256Hex("测试");
String sha3_384 = DigestUtils.sha3_384Hex("测试");
String sha3_512 = DigestUtils.sha3_512Hex("测试");

String key = "asdf3234asdf3234asdf3234asdf3234";
String valueToDigest = "测试数据"; // valueToDigest参数支持字节数据，流，文件等
// 做HMAC-MD5摘要
String hmacMd5 = new HmacUtils(HmacAlgorithms.HMAC_MD5, key).hmacHex(valueToDigest);
// 做HMAC-sha摘要
String hmacSha256 = new HmacUtils(HmacAlgorithms.HMAC_SHA_256, key).hmacHex(valueToDigest);
String hmacSha384 = new HmacUtils(HmacAlgorithms.HMAC_SHA_384, key).hmacHex(valueToDigest);
String hmacSha512 = new HmacUtils(HmacAlgorithms.HMAC_SHA_512, key).hmacHex(valueToDigest);
```

### 4. Compress
<img src="D:\Project\IT-notes\技术要点\img\apache-commons-compress.png" style="width:700px;height:200px;" />

#### 1. 压缩
- `.gz`：`GzipCompressorOutputStream、GzipCompressorInputStream`
- `.bz2`：`BZip2CompressorOutputStream、BZip2CompressorInputStream`
- `.xz`：`XZCompressorOutputStream、XZCompressorInputStream`
- `.lz4`：`FramedLZ4CompressorOutputStream、FramedLZ4CompressorInputStream`
- `.block_lz4`：`BlockLZ4CompressorOutputStream、BlockLZ4CompressorInputStream`
- `.pack`：`Pack200CompressorOutputStream、Pack200CompressorInputStream`
- `.deflate`：`DeflateCompressorOutputStream、DeflateCompressorInputStream`
- `.lzma`：`LZMACompressorOutputStream、LZMACompressorInputStream`
- `.sz`：`FramedSnappyCompressorOutputStream、FramedSnappyCompressorInputStream`
- `.z`：`ZCompressorInputStream`

```java
// gzip压缩
String file = "/test.js";
GzipParameters parameters = new GzipParameters();
parameters.setCompressionLevel(Deflater.BEST_COMPRESSION);
parameters.setOperatingSystem(3);
parameters.setFilename(FilenameUtils.getName(file));
parameters.setComment("Test file");
parameters.setModificationTime(System.currentTimeMillis());
FileOutputStream fos = new FileOutputStream(file + ".gz");
try (GzipCompressorOutputStream gzos = new GzipCompressorOutputStream(fos, parameters);
    InputStream is = new FileInputStream(file)) {
    IOUtils.copy(is, gzos);
}
// gzip解压
String gzFile = "/test.js.gz";
FileInputStream is = new FileInputStream(gzFile);
try (GzipCompressorInputStream gis = new GzipCompressorInputStream(is)) {
    GzipParameters p = gis.getMetaData();
    File targetFile = new File("/test.js");
    FileUtils.copyToFile(gis, targetFile);
    targetFile.setLastModified(p.getModificationTime());
}


// 压缩bz2
String srcFile = "/test.tar";
String targetFile = "/test.tar.bz2";
FileOutputStream os = new FileOutputStream(targetFile);
try (BZip2CompressorOutputStream bzos = new BZip2CompressorOutputStream(os);
    InputStream is = new FileInputStream(srcFile)) {
    IOUtils.copy(is, bzos);
}
// 解压bz2
String bzFile = "/test.tar.bz2";
FileInputStream is = new FileInputStream(bzFile);
try (BZip2CompressorInputStream bzis = new BZip2CompressorInputStream(is)) {
    File targetFile = new File("test.tar");
    FileUtils.copyToFile(bzis, targetFile);
}
```

#### 2. 归档
- `.tar`：`TarArchiveOutputStream、TarArchiveInputStream`
- `.zip`：`ZipArchiveOutputStream、ZipArchiveInputStream`
- `.jar`：`JarArchiveOutputStream、JarArchiveInputStream`
- `.dump`：`DumpArchiveOutputStream、DumpArchiveInputStream`
- `.cpio`：`CpioArchiveOutputStream、CpioArchiveInputStream`
- `.ar`：`ArArchiveOutputStream、ArArchiveInputStream`
- `.arj`：`ArjArchiveInputStream`
- `.7z`：`SevenZOutputFile、SevenZFile`

```java
// tar压缩
public void tar() throws IOException {
    File srcDir = new File("/test");
    String targetFile = "/test.tar";
    try (TarArchiveOutputStream tos = new TarArchiveOutputStream(
            new FileOutputStream(targetFile))) {
        tarRecursive(tos, srcDir, "");
    }
}
// 递归压缩目录下的文件和目录
private void tarRecursive(TarArchiveOutputStream tos, File srcFile, String basePath) 
	throws IOException {
    if (srcFile.isDirectory()) {
        File[] files = srcFile.listFiles();
        String nextBasePath = basePath + srcFile.getName() + "/";
        if (ArrayUtils.isEmpty(files)) {
            // 空目录
            TarArchiveEntry entry = new TarArchiveEntry(srcFile, nextBasePath);
            tos.putArchiveEntry(entry);
            tos.closeArchiveEntry();
        } else {
            for (File file : files) {
                tarRecursive(tos, file, nextBasePath);
            }
        }
    } else {
        TarArchiveEntry entry = new TarArchiveEntry(srcFile, basePath + srcFile.getName());
        tos.putArchiveEntry(entry);
        FileUtils.copyFile(srcFile, tos);
        tos.closeArchiveEntry();
    }
}
// tar解压
public void untar() throws IOException {
    InputStream is = new FileInputStream("/test.tar");
    String outPath = "/test";
    try (TarArchiveInputStream tis = new TarArchiveInputStream(is)) {
        TarArchiveEntry nextEntry;
        while ((nextEntry = tis.getNextTarEntry()) != null) {
            String name = nextEntry.getName();
            File file = new File(outPath, name);
            //如果是目录，创建目录
            if (nextEntry.isDirectory()) {
                file.mkdir();
            } else {
                //文件则写入具体的路径中
                FileUtils.copyToFile(tis, file);
                file.setLastModified(nextEntry.getLastModifiedDate().getTime());
            }
        }
    }
}



// 7z压缩
public void _7z() throws IOException {
    try (SevenZOutputFile outputFile = new SevenZOutputFile(new File("/test.7z"))) {
        File srcFile = new File("/test");
        _7zRecursive(outputFile, srcFile, "");
    }
}
// 递归压缩目录下的文件和目录
private void _7zRecursive(SevenZOutputFile _7zFile, File srcFile, String basePath) 
	throws IOException {
    if (srcFile.isDirectory()) {
        File[] files = srcFile.listFiles();
        String nextBasePath = basePath + srcFile.getName() + "/";
        // 空目录
        if (ArrayUtils.isEmpty(files)) {
            SevenZArchiveEntry entry = _7zFile.createArchiveEntry(srcFile, nextBasePath);
            _7zFile.putArchiveEntry(entry);
            _7zFile.closeArchiveEntry();
        } else {
            for (File file : files) {
                _7zRecursive(_7zFile, file, nextBasePath);
            }
        }
    } else {
        SevenZArchiveEntry entry = _7zFile.createArchiveEntry(srcFile, basePath + srcFile.getName());
        _7zFile.putArchiveEntry(entry);
        byte[] bs = FileUtils.readFileToByteArray(srcFile);
        _7zFile.write(bs);
        _7zFile.closeArchiveEntry();
    }
}
 // 7z解压
public void un7z() throws IOException {
    String outPath = "/test";
    try (SevenZFile archive = new SevenZFile(new File("test.7z"))) {
        SevenZArchiveEntry entry;
        while ((entry = archive.getNextEntry()) != null) {
            File file = new File(outPath, entry.getName());
            if (entry.isDirectory()) {
                file.mkdirs();
            }
            if (entry.hasStream()) {
                final byte [] buf = new byte [1024];
                final ByteArrayOutputStream baos = new ByteArrayOutputStream();
                for (int len = 0; (len = archive.read(buf)) > 0;) {
                    baos.write(buf, 0, len);
                }
                FileUtils.writeByteArrayToFile(file, baos.toByteArray());
            }
        }
    }
}
```

#### 3. 修改归档
```java
String tarFile = "/test.tar";
InputStream is = new FileInputStream(tarFile);
// 替换后会覆盖原test.tar，如果是windows可能会由于文件被访问而覆盖报错
OutputStream os = new FileOutputStream(tarFile);
try (TarArchiveInputStream tais = new TarArchiveInputStream(is);
     TarArchiveOutputStream taos = new TarArchiveOutputStream(os)) {
    ChangeSet changes = new ChangeSet();
    // 删除"test.tar中"的"dir/1.txt"文件
    changes.delete("dir/1.txt");
    // 删除"test.tar"中的"t"目录
    changes.delete("t");
    // 添加文件，如果已存在则替换
    File addFile = new File("/a.txt");
    ArchiveEntry addEntry = taos.createArchiveEntry(addFile, addFile.getName());
    // add可传第三个参数：true: 已存在则替换(默认值)， false: 不替换
    changes.add(addEntry, new FileInputStream(addFile));
    // 执行修改
    ChangeSetPerformer performer = new ChangeSetPerformer(changes);
    ChangeSetResults result = performer.perform(tais, taos);
}
```

#### 4. 其他
```java
//动态获取流
// 使用factory动态获取归档流
ArchiveStreamFactory factory = new ArchiveStreamFactory();
String archiveName = ArchiveStreamFactory.TAR;
InputStream is = new FileInputStream("/in.tar");
OutputStream os = new FileOutputStream("/out.tar");
// 动态获取实现类，此时ais实际上是TarArchiveOutPutStream
ArchiveInputStream ais = factory.createArchiveInputStream(archiveName, is);
ArchiveOutputStream aos = factory.createArchiveOutputStream(archiveName, os);

// 使用factory动态获取压缩流
CompressorStreamFactory factory = new CompressorStreamFactory();
String compressName = CompressorStreamFactory.GZIP;
InputStream is = new FileInputStream("/in.gz");
OutputStream os = new FileOutputStream("/out.gz");
// 动态获取实现类，此时ais实际上是TarArchiveOutPutStream
CompressorInputStream cis = factory.createCompressorInputStream(compressName, is);
CompressorOutputStream cos = factory.createCompressorOutputStream(compressName, os);

//同时解压解包压缩归档于一体的文件
// 解压 解包test.tar.gz文件
String outPath = "/test";
InputStream is = new FileInputStream("/test.tar.gz");
// 先解压，所以需要先用gzip流包装文件流
CompressorInputStream gis = new GzipCompressorInputStream(is);
// 在解包，用tar流包装gzip流
try (ArchiveInputStream tgis = new TarArchiveInputStream(gis)) {
    ArchiveEntry nextEntry;
    while ((nextEntry = tgis.getNextEntry()) != null) {
        String name = nextEntry.getName();
        File file = new File(outPath, name);
        // 如果是目录，创建目录
        if (nextEntry.isDirectory()) {
            file.mkdir();
        } else {
            // 文件则写入具体的路径中
            FileUtils.copyToFile(tgis, file);
            file.setLastModified(nextEntry.getLastModifiedDate().getTime());
        }
    }
}
```

### 5. Exec

## 6. SpringUtils


## 7. EasyExcel


## 8. Captcha

