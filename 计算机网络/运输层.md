## 1. 概述
从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于通信部分的最高层，同时也是用户功能中的最低层。当网络的边缘部分中的两台主机使用网络的核心部分的功能进行端到端的通信时，只有主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。

从IP层来说，通信的两端是两台主机。IP数据报的首部明确地标志了这两台主机的IP地址。而真正进行通信的实体是在主机中的进程，是这台主机中的一个进程和另一台主机中的一个进程在交换数据，即两台主机进行通信就是两台主机中的应用进程互相通信。IP协议虽然能把分组送到目的主机，但是这个分组还停留在主机的网络层而没有交付主机中的应用进程。从运输层的角度看，通信的真正端点并不是主机而是主机中的进程。也就是说，端到端的通信是应用进程之间的通信。在一台主机中经常有多个应用进程同时分别和另一台主机中的多个应用进程通信。

**网络层为主机之间提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信**

## 2. 运输层两个主要协议
**用户数据报协议UDP、传输控制协议TCP**

UDP在传送数据之前不需要先建立连接。远地主机的运输层在收到UDP报文后，不需要给出任何确认。虽然UDP不提供可靠交付，但在某些情况下UDP却是一种最有效的工作方式。

TCP提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务。由于TCP提供可靠的、面向连接的运输服务，因此不可避免增加了开销，如确认、流量控制、计时器以及连接管理等。

## 3. 运输层端口
运输层使用协议端口号，简称端口，虽然通信的终点是应用进程，但只要所传送的报文交到目的主机的某个合适的目的端口，剩下的工作（交付目的进程）就由TCP或UDP完成。
在UDP或TCP报文首部中，存在源端口和目的端口两个重要字段。当运输层收到IP层交上来的运输层报文时，就能够根据其首部中的目的端口号把数据交付应用层的目的应用进程。而运输层使用一个16位端口号标志一个端口。端口号只具有本地意义，标志本计算机应用层中的各个进程在和运输层交互时的层间接口。

因此，计算机进程通信的前提是需要知道对方的IP地址，应用进程的端口号。

端口号类型：
1. 服务器端使用的端口号：
	- 熟知端口号（系统端口号）：0~1023 一些TCP/IP最重要的应用程序的端口号
	- 登记端口号：1024~49151 为没有熟知端口号的应用程序使用
2. 客户端使用的端口号（短暂端口号）：49152~65535 仅在客户进程运行时才动态选择的端口号。当服务器进程收到客户进程的报文时，知道客户进程使用的端口号，则可把数据发送给客户进程。通信结束后使用过的客户端口号则不复存在。

## 4. UDP
### 1. UDP概述
UDP只在IP的数据报服务上增加很少一点功能，即复用分用、差错检测

UDP特点：
1. UDP是无连接的，即发送数据之前不需要建立连接
2. UDP使用尽最大努力交付，不保证可靠交付
3. UDP面向报文，对应用层下交的报文既不合并也不拆分，而是保留这些报文的边界；对IP层上交的数据报在去除首部后原文交付上层应用进程
4. UDP没有拥塞控制，网络出现拥塞不会使主机发送速率下降
5. UDP支持一对一、一对多、多对一、多对多的交互通信
6. UDP首部开销小

### 2. UDP报文格式

![UDP首部格式](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2F20210307221618852.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpbmNlbnRfd2VuMDc2Ng%3D%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70&refer=http%3A%2F%2Fimg-blog.csdnimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1647502049&t=c26b43fc66ecbb833f1e0274c443182f "UDP首部格式")

用户数据报UDP有两个字段：数据字段和首部字段。首部字段只有8个字节，由四个字段组成，每个字段的长度都是两个字节：
1. 源端口：源端口号，在需要对方回信时选用，不需要时可用全0
2. 目的端口：目的端口号，这在终点交付报文时必须使用
3. 长度：UDP用户数据报的长度，其最小值是8
4. 校验和：校验UDP用户数据报在传输中是否有错，有错则丢弃

**当运输层从IP层收到UDP数据报时，就根据首部中的目的端口，把UDP数据报通过相应的端口，上交最后的终点--应用进程**

如果接收方UDP发现收到的报文中的目的端口号不正确（不存在对应于该端口号的进程）则丢弃该报文，并由网际控制报文协议ICMP发送“端口不可达”差错报文。

UDP用户数据报首部中校验和的计算方法有些特殊。在计算校验和时，要在UDP用户数据报之前增加12个字节的伪首部。所谓“伪首部”是因为这种伪首部并不是UDP用户数据报的真正首部。只是在计算校验和时，临时添加在UDP用户数据报前面，得到一个临时的UDP用户数据报。校验和按照这个临时的UDP用户数据报来计算的。伪首部既不向下传送也不向上提交，仅仅为了计算校验和。

## 5. TCP
### 1. TCP特点
TCP协议最主要特点：
1. TCP是面向连接的运输层协议，应用程序在使用TCP之前，必须先建立TCP连接。传送数据完毕后，必须释放已建立的TCP连接
2. 每一条TCP连接只能有两个端点，TCP只能点到点
3. TCP提供可靠交付的服务
4. TCP支持全双工通信
5. 面向字节流

![TCP面向字节流](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2020.cnblogs.com%2Fblog%2F1104875%2F202009%2F1104875-20200907181540063-1861120422.png&refer=http%3A%2F%2Fimg2020.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1647527180&t=70e2a67971af15d3c3158524eac03233 "TCP面向字节流")

TCP和UDP在发送报文时所采用的方式完全不同。TCP并不关心应用进程一次把多长的报文发送到TCP的缓存中，而是根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP发送的报文长度是应用进程给出的）。如果应用进程传送到TCP缓存的数据块太长，TCP就可以把它划分短一些再传送。如果应用进程一次只发送一个字节，TCP也可以等待积累足够多字节后再构成报文段发送。

### 2. TCP连接
TCP连接的端点叫做**套接字**：套接字socket = (IP地址：端口号)

每一条TCP连接唯一地被通信两端的两个端点所确定：
TCP连接 = {socket1, socket2} = {(IP1: port1), (IP2: port2)}

### 3. 可靠传输的工作原理
#### 1. 停止等待协议（自动重传请求ARQ）

![无差错情况和超时重传](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimages.cnitblog.com%2Fblog%2F468782%2F201410%2F032004386751985.gif&refer=http%3A%2F%2Fimages.cnitblog.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1647528384&t=9dbfaecbb008baf931b378e45f4a07f7 "无差错情况和超时重传")

需注意三点：
1. A在发送完一个分组后，必须暂时保留已发送的分组的副本（在发生超时重传时使用）。只有在收到相应的确认后才能清除暂存的分组副本
2. 分组和确认分组必须进行编号，为了明确哪个发送出去的分组收到确认，哪一个没有
3. 超时计时器设置的重传时间应当比数据在分组传输的平均往返时间更长一些

![确认丢失和确认迟到](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.myexception.cn%2Fimg%2F2015%2F08%2F01%2F093206986.png&refer=http%3A%2F%2Fwww.myexception.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1647528775&t=e1d6abbe61477f6c4bb2fcac7ec27139 "确认丢失和确认迟到")

#### 2. 连续ARQ协议
因为简单ARQ协议存在信道利用率低下，因此出现连续ARQ协议

![连续ARQ](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fmy-1255788407.cos.ap-shanghai.myqcloud.com%2Fstop_wait_protocol_assembly_line.png&refer=http%3A%2F%2Fmy-1255788407.cos.ap-shanghai.myqcloud.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1647529081&t=636dcc874b721e377577b44c1d422c0f "连续ARQ")

![连续ARQ](https://img1.baidu.com/it/u=1087077840,1705480998&fm=253&fmt=auto&app=138&f=PNG?w=782&h=431 "连续ARQ")

连续ARQ协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。接收方一般采用累计确认的方式，接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，对按序到达的最后一个分组发送确认，表示到这个分组为止的所有分组都已正确收到。

#### 3. TCP报文段格式

![TCP报文格式](https://img2.baidu.com/it/u=1465037225,3276133480&fm=253&fmt=auto&app=138&f=PNG?w=500&h=347 "TCP报文格式")

1. 源端口和目的端口：各占2个字节，分别写入源端口号和目的端口号
2. 序号：TCP面向字节流，在一个TCP连接中传送的字节流中的每一个字节都按照顺序编号。整个要传送的字节流的起始序号必须在连接建立时设置。首部中的序号字段值则指的是本报文段所发送的数据的第一个字节的序号
3. 确认号：期望收到对方下一个报文段的第一个数据字节的序号
4. 数据偏移：指出TCP报文段的数据起始处距离TCP报文段的起始处有多远，即首部长度
5. 保留
6. 信号位：紧急URG、确认ACK、推送PSH、复位RST、同步SYN、终止FIN，这若干信号位确定了报文的性质
7. 窗口：指的是发送本报文段的一方的接收窗口
8. 校验和
9. 紧急指针
10. 选项

#### 4. TCP可靠传输的实现
TCP的滑动窗口是以字节为单位的。
发送窗口表示：在没有收到对方的确认的情况下，发送方可以连续把窗口内的数据都发送出去。凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便在超时重传时使用。
发送窗口里面的序号表示允许发送的序号。窗口越大，发送方就可以在收到对方确认之前连续发送更多数据，提高传输效率。

![发送窗口](https://img0.baidu.com/it/u=3692154336,1567731389&fm=253&fmt=auto&app=138&f=PNG?w=762&h=256 "发送窗口")

发送窗口后沿的后面部分表示已发送且已收到了确认，这些数据不需要再保留。发送窗口前沿的前面部分表示不允许发送的，因为接收方都没有为这部分数据保留临时存放的缓存空间。
发送窗口的位置由窗口前沿和后沿的位置共同确定。发送窗口后沿的变化情况分为：不动（没有收到新的确认）、前移（收到新的确认）。发送窗口后沿不可能向后移动，因为不可能撤销已收到的确认。发送窗口前沿通常是不断向前移动的，但也有可能不动，情况分为两种：没有收到新的确认且对方通知的窗口大小也不变、收到新的确认但对方通知的窗口缩小了。

![TCP可靠传输](https://img-blog.csdn.net/20150418231645814 "TCP可靠传输")

![TCP可靠传输](https://img-blog.csdn.net/20150418233002002 "TCP可靠传输")

![TCP发送接收缓存](https://img-blog.csdn.net/20150418233509775 "TCP发送接收缓存")

三点强调：
1. 虽然A的发送窗口是根据B的接收窗口设置的，但在同一时刻，A的发送窗口并不总是和B的接收窗口一样大。通过网络传送窗口值是需要时间的。发送方可以根据网络拥塞程度减小自己的发送窗口值
2. 对于不按序到达的数据，接收方可以为了简单管理一律丢弃，但会给网络增加压力；为了节省网络资源接收方可以把不按序到达的数据缓存在接收窗口中
3. TCP要求接收方必须有累计确认的功能，这样可以减小传输开销。接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息捎带。

超时重传的时间选择……

对于未按序到达的报文段，可以通过**选择确认SACK**实现只传送缺少的数据而不重传已经正确到达接收方的数据：在TCP首部的选项中加上“允许SACK”，事先在建立连接时协商好，以便报告收到的不连续的字节块的边界。

### 4. TCP流量控制
如果发送方把数据发送得过快，接收方可能来不及接收，造成数据丢失。所谓**流量控制**，就是让发送方的发送速率不要太快，要让接收方来得及接收。、
**使用滑动窗口机制进行流量控制**

![滑动窗口机制](https://img2.baidu.com/it/u=3721439488,736074913&fm=253&fmt=auto&app=138&f=JPEG?w=793&h=414 "滑动窗口机制")

**如果存在接收方发送的零窗口报文段丢失，造成发送方等待接收方的非零窗口报文，而接收方等待发送方报文的死锁情况，发送方设有持续计时器在接收到零窗口报文后进行计数，若计时器到期，则发送一个零窗口探测报文段，对方返回带有目前窗口值的确认报文段：若窗口值仍为零，则计时器重新计时。**

### 5. TCP的拥塞控制
TCP 采用**基于窗口的方法**进行拥塞控制。该方法属于闭环控制方法。  
TCP发送方维持一个**拥塞窗口 cwnd (Congestion Window)**  
发送端利用**拥塞窗口**根据网络的拥塞情况调整发送的数据量

只要网络没有出现拥塞，拥塞窗口就可以再增大一些，以便把更多的分组发送出去，这样就可以提高网络的利用率。  
但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些，以减少注入到网络中的分组数，以便缓解网络出现的拥塞。

四种拥塞控制算法：
1. 慢开始 (slow-start)  
2. 拥塞避免 (congestion avoidance)  
3. 快重传 (fast retransmit)  
4. 快恢复 (fast recovery)

![拥塞控制算法](https://img0.baidu.com/it/u=3164411985,1628090942&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=268 "拥塞控制算法")

#### 1. 慢开始
目的：用来确定网络的负载能力或拥塞程度。  
算法的思路：由小到大逐渐增大拥塞窗口数值。

主机开始发送数据报时，如果立即将大量的数据注入到网络中，可能会出现网络的拥塞。慢启动算法就是在主机刚开始发送数据报的时候先探测一下网络的状况，如果网络状况良好，发送方每发送一次文段都能正确的接受确认报文段。那么就从小到大的增加拥塞窗口的大小，即增加发送窗口的大小。

例子：开始发送方先设置cwnd（拥塞窗口）=1,发送第一个报文段M1，接收方接收到M1后，发送方接收到接收方的确认后，把cwnd增加到2，接着发送方发送M2、M3，发送方接收到接收方发送的确认后cwnd增加到4，慢启动算法每经过一个传输轮次（认为发送方都成功接收接收方的确认），拥塞窗口cwnd就加倍。

#### 2. 拥塞避免
为了防止cwnd增加过快而导致网络拥塞，所以需要设置一个慢开始门限ssthresh状态变量,它的用法：
1.  当cwnd < ssthresh,使用慢启动算法，
2.  当cwnd > ssthresh,使用拥塞控制算法，停用慢启动算法。
3.  当cwnd = ssthresh，这两个算法都可以。

拥塞避免的思路：是让cwnd缓慢的增加而不是加倍的增长，每经历过一次往返时间就使cwnd增加1，而不是加倍，这样使cwnd缓慢的增长，比慢启动要慢的多。

无论是慢启动算法还是拥塞避免算法，只要判断网络出现拥塞，就要把慢启动开始门限(ssthresh)设置为设置为发送窗口的一半（>=2），cwnd(拥塞窗口)设置为1，然后在使用慢启动算法，这样做的目的能迅速的减少主机向网络中传输数据，使发生拥塞的路由器能够把队列中堆积的分组处理完毕。拥塞窗口是按照线性的规律增长，比慢启动算法拥塞窗口增长块的多。

实例：  
1.TCP连接进行初始化的时候，cwnd=1,ssthresh=16。  
2.在慢启动算法开始时，cwnd的初始值是1，每次发送方收到一个ACK拥塞窗口就增加1，当ssthresh =cwnd时，就启动拥塞控制算法，拥塞窗口按照规律增长，  
3.当cwnd=24时，网络出现超时，发送方收不到确认ACK，此时设置ssthresh=12,(二分之一cwnd),设置cwnd=1,然后开始慢启动算法，当cwnd=ssthresh=12,慢启动算法变为拥塞控制算法，cwnd按照线性的速度进行增长。

#### 3. 快重传
快重传算法要求首先接收方收到一个失序的报文段后就立刻发出重复确认，而不要等待自己发送数据时才进行捎带确认。接收方成功的接受了发送方发送来的M1、M2并且分别给发送了ACK，现在接收方没有收到M3，而接收到了M4，显然接收方不能确认M4，因为M4是失序的报文段。如果根据可靠性传输原理接收方什么都不做，但是按照快速重传算法，在收到M4、M5等报文段的时候，不断重复的向发送方发送M2的ACK,如果接收方一连收到三个重复的ACK,那么发送方不必等待重传计时器到期，由于发送方尽早重传未被确认的报文段。

#### 4. 快恢复
1.  当发送发连续接收到三个确认时，就执行乘法减小算法，把慢启动开始门限（ssthresh）减半，但是接下来并不执行慢开始算法。
2.  此时不执行慢启动算法，而是把cwnd设置为ssthresh的一半， 然后执行拥塞避免算法，使拥塞窗口缓慢增大

![拥塞窗口](https://img1.baidu.com/it/u=2573687351,2653023031&fm=253&fmt=auto&app=138&f=PNG?w=1269&h=500 "拥塞窗口")

![拥塞窗口](https://img1.baidu.com/it/u=410143388,467995863&fm=253&fmt=auto&app=138&f=JPEG?w=788&h=403 "拥塞窗口")

#### 主动队列管理AQM
假如一个路由器对某些分组的处理时间较长，这可能使TCP报文经过较长时间才能到达终点，引起发送方对这些报文段的重传，而重传会使TCP连接的发送端认为网络发生拥塞，于是执行拥塞控制。
而路由器的分组队列出现溢出造成的分组丢失也能使发送方超时重传。在网络中许多TCP连接有可能复用IP网络层，因此会造成全局同步（多条TCP连接进入拥塞控制）

为了避免全局同步，使用**主动队列管理AQM**，在路由器分组队列达到最大值之前的某一临界值时主动丢弃分组，**随机早期检测RED**就是AQM的其中一个实现方法：
1. RED使路由器维持两个参数，队列长度最小门限以及队列长度最大门限
2. RED计算得出当前队列平均队列长度
3. 若平均队列长度小于最小门限，则把新到达的分组放入队列进行排队
4. 若平均队列长度超过最大门限，则把新到达的分组丢弃
5. 若平均队列长度在最小门限和最大门限之间，则按照某一丢弃概率P把新到达的分组丢弃

### 6. TCP连接管理
#### 1. TCP建立连接的三次握手
![建立连接的三次握手](https://img0.baidu.com/it/u=2911282218,4160570683&fm=253&fmt=auto&app=138&f=JPEG?w=640&h=424 "建立连接的三次握手")

<img src="D:\Project\IT-notes\计算机网络\img\三次握手.png" style="width:700px;height:400px;" />

1. 客户端主动打开，发送连接请求报文段，将`SYN`标识位置为1，`Sequence Number`置为x（TCP规定`SYN=1`时不能携带数据，`x`为随机产生的一个值），然后进入`SYN_SEND`状态
2. 服务器收到`SYN`报文段进行确认，将`SYN`标识位置为1，`ACK`置为1，`Sequence Number`置为`y`，`Acknowledgment Number`置为`x+1`，然后进入`SYN_RECV`状态，这个状态被称为半连接状态
3. 客户端再进行一次确认，将`ACK`置为1（此时不用`SYN`），`Sequence Number`置为`x+1`，`Acknowledgment Number`置为`y+1`发向服务器，最后客户端与服务器都进入`ESTABLISHED`状态

**第三步确认的原因：防止已经失效的连接请求报文段突然又传回到服务端而产生错误的场景**
- 所谓"已失效的连接请求报文段"是这样产生的。正常来说，客户端发出连接请求，但因为连接请求报文丢失而未收到确认。于是客户端再次发出一次连接请求，后来收到了确认，建立了连接。数据传输完毕后，释放了连接，客户端一共发送了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，没有"已失效的连接请求报文段"
- 现在假定一种异常情况，即客户端发出的第一个连接请求报文段并没有丢失，只是在某些网络节点长时间滞留了，以至于延误到连接释放以后的某个时间点才到达服务端。本来这个连接请求已经失效了，但是服务端收到此失效的连接请求报文段后，就误认为这是客户端又发出了一次新的连接请求。于是服务端又向客户端发出请求报文段，同意建立连接。假定不采用三次握手，那么只要服务端发出确认，连接就建立了
- 由于现在客户端并没有发出连接建立的请求，因此不会理会服务端的确认，也不会向服务端发送数据，但是服务端却以为新的传输连接已经建立了，并一直等待客户端发来数据，这样服务端的许多资源就这样白白浪费了

#### 2. TCP释放连接的四次挥手
![释放连接的四次挥手](https://img1.baidu.com/it/u=1856521220,1796733198&fm=253&fmt=auto&app=138&f=JPEG?w=720&h=456 "释放连接的四次挥手")

<img src="D:\Project\IT notes\计算机网络\img\四次挥手.png" style="width:700px;height:600px;" />

1. 客户端发送一个报文给服务端（没有数据），其中`FIN`设置为1，`Sequence Number`置为`u`，客户端进入`FIN_WAIT_1`状态
2. 服务端收到来自客户端的请求，发送一个`ACK`给客户端，`Acknowledge`置为`u+1`，同时发送`Sequence Number`为`v`，服务端年进入`CLOSE_WAIT`状态
3. 服务端发送一个`FIN`给客户端，`ACK`置为1，`Sequence`置为w，`Acknowledge`置为u+1，用来关闭服务端到客户端的数据传送，服务端进入`LAST_ACK`状态
4. 客户端收到`FIN`后，进入`TIME_WAIT`状态，接着发送一个`ACK`给服务端，`Acknowledge`置为`w+1`，`Sequence Number`置为`u+1`，最后客户端和服务端都进入`CLOSED`状态

握手需要三次而挥手需要四次的原因：
- 因为服务端在`LISTEN`状态下，收到建立请求的`SYN`报文后，把`ACK`和`SYN`放在一个报文里发送给客户端。而连接关闭时，当收到对方的`FIN`报文时，仅仅表示对方没有需要发送的数据了，但是还能接收数据，己方未必数据已经全部发送给对方了，所以己方可以立即关闭，也可以将应该发送的数据全部发送完毕后再发送`FIN`报文给客户端来表示同意现在关闭连接

需要客户端等待`2MSL`时间（即TIME_WAIT的时间要大于等于客户端收到服务端超时重传的FIN的时间）的原因：
- 服务端判断需要重传的时间是`1MSL`。任何报文段在网络中的最大生命周期是`1MSL`，所以当被动方在`1MSL`内没有收到`ACK`，就会重传`FIN`
- `FIN`到达客户端的时间是`1MSL`。重传的`FIN`最慢到达客户端的时间是`1MSL`

#### 3. TCP状态机
![TCP状态机](https://img2.baidu.com/it/u=3757274041,416495667&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=580 "TCP状态机")
